# 인터넷 네트워크

## 인터넷 통신

## IP(인터넷 프로토콜)
노드끼리 통신하면서 해당 IP를 탐색해 패킷을 보낸다

### 한계
- 비연결성:

패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

- 비신뢰성: 

중간에 패킷이 사라지는 경우

순서대로 오지 않는 경우

- 프로그램 구분:

같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상인 경우

## TCP, UDP

### TCP
TCP 3 way handshake

- SYN: 접속 요청
- ACK: 요청 수락
- ACK와 함께 데이터 전송 가능(요즘은 최적화가 되어서)

1. SYN
2. SYN + ACK
3. ACK

데이터 받았다고 전송해줌

순서도 보장해줌(1, 2, 3으로 보냈는데 1, 3, 2로 오면 버리고 2번부터 다시 보내게 함)

### UDP
거의 기능이 없음

요즘 각광받고 있음

## PORT

## DNS 

# 섹션 2 URI와 웹브라우저 요청 흐름

## URI

URI는 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다

URI(리소스 식별) 안에 URL(Resource Locator)과 URN(Resource Name)이 있다

### 단어 뜻
- Uniform: 리소스 식별 통일 방식
- Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음)
- Identifier: 다른 항목과 구분하는데 필요한 정보

- URL-Locator: 리소스가 있는 위치를 지정
- URN-Name: 리소스에 이름을 부여

### 구조

scheme://[userinfo@]host[:port][/path][?query][#fragment]

scheme: 주로 프로토콜 사용(http, https, ftp)
    - 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
    - http는 80 포트, https는 443 포트를 주로 사용, 포트 생략 가능

userinfo: 거의 사용하지 않음, URL에 사용자 정보를 포함해서 인증해야 할 때 사용

host: 도메인 명, IP 주소 입력

port: 생략 가능, 생략시 http는 80, https는 443 -> 특정 포트로 들어가야할 땐 입력

path: 리소스가 있는 경로, 계층적 구조

query: 
    - key=value 형태
    - ?로 시작하고 &으로 추가 가능
    - query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태

## 웹 브라우저 요청 흐름

1. 주소 입력
2. DNS 조회
3. IP와 포트 정보 찾아서 HTTP 요청 메시지 생성
> GET /search?q=hello&hl=ko HTTP/1.1 </br> Host: www.google.com
4. SOCKET 라이브러리를 통해 전달(TCP/IP 연결)

# 섹션 1 HTTP 기본

## 모든 것이 HTTP

HyperText Transfer Protocol

HTTP 메시지에 모든 것을 전송 가능

HTTP/1.1 1997년 버전에 가장 많은 기능이 있고, 우리에게 가장 중요한 버전(가장 많이 사용)

뒤에는 성능개선

클라이언트 - 서버 구조로 동작

무상태 프로토콜(Stateless) 비연결성

HTTP 메시지

단순함, 확장 가능

## 클라이언트 서버 구조

클라이언트와 서버가 각각 독립적(서버는 데이터, 클라이언트는 UI 화면 등)

## Stateful, Stateless 차이

어떠한 정보의 상태를 유지하는 것의 차이

상태 유지: 중간에 다른 점원으로 바뀌면 안된다(바뀌면 상태 정보를 알려줘야 한다)

무상태: 중간에 바뀌어도 된다

무상태는 응답 서버를 쉽게 바꿀 수 있다

Stateful은 항상 같은 서버가 유지되어야 한다

Stateless는 아무 서버나 호출해도 된다(클라이언트에 정보가 있다) -> 스케일 아웃(수평 확장)에 유리

### Stateless의 한계?
- 단순한 서비스 소개 화면(무상태 설계 쉬움, 정보가 필요 없음)
- 상태 유지(로그인) -> 쿠키와 서버 세션 등을 사용해서 상태 유지, 상태 유지는 최소한만 사용

## 비연결성
HTTP는 기본적으로 연결을 유지하지 않는 모델

### 한계와 극복
TCP/IP 연결을 새로 해야하면 3 way handshake 시간 추가

수 많은 자원이 함께 다운로드 된다

지금은 HTTP 지속 연결(persistance connection)로 문제 해결

## HTTP 메시지

### 메시지의 구조

start-line: 시작 라인

header: 헤더

empty line: 공백 라인(CRLF)

message body

### 시작 라인 - 요청 메시지
#### HTTP 메서드

종류: GET, POST, DELETE, PUT ...

서버가 수행해야 할 동작 지정
- GET: 리소스 조회
- POST: 요청 내역 처리

#### 요청 대상
절대경로[?query]

절대경로 = "/"로 시작하는 경로

#### HTTP 버전

### 응답 메시지

### 시작 라인 - 응답 메시지
start-line = request-line / status-line

status-line = HTTP-version status-code reason-pharse CRLF

HTTP 버전

HTTP 상태 코드: 요청 성공, 실패
- 200: 성공
- 400: 클라이언트 요청 오류
- 500: 서버 내부 오류

이유 문구: 짧은 상태 코드 설명 글

### HTTP 헤더
header-field = field-name ":" OWS field-value OWS

field-name은 대소문자 구분 없음

헤더의 용도: HTTP 전송에 필요한 모든 부가 정보 저장

ex) 메시지 바디 내용, 메시지 바디 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보...

표준 헤더가 매우 많다

임의 헤더 추가도 가능하다

### HTTP 메시지 바디

실제 전송 데이터

byte로 표현 가능한 모든 데이터 전송