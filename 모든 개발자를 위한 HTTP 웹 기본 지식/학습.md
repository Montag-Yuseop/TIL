# 인터넷 네트워크

## 인터넷 통신

## IP(인터넷 프로토콜)
노드끼리 통신하면서 해당 IP를 탐색해 패킷을 보낸다

### 한계
- 비연결성:

패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

- 비신뢰성: 

중간에 패킷이 사라지는 경우

순서대로 오지 않는 경우

- 프로그램 구분:

같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상인 경우

## TCP, UDP

### TCP
TCP 3 way handshake

- SYN: 접속 요청
- ACK: 요청 수락
- ACK와 함께 데이터 전송 가능(요즘은 최적화가 되어서)

1. SYN
2. SYN + ACK
3. ACK

데이터 받았다고 전송해줌

순서도 보장해줌(1, 2, 3으로 보냈는데 1, 3, 2로 오면 버리고 2번부터 다시 보내게 함)

### UDP
거의 기능이 없음

요즘 각광받고 있음

## PORT

## DNS 

# 섹션 2 URI와 웹브라우저 요청 흐름

## URI

URI는 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다

URI(리소스 식별) 안에 URL(Resource Locator)과 URN(Resource Name)이 있다

### 단어 뜻
- Uniform: 리소스 식별 통일 방식
- Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음)
- Identifier: 다른 항목과 구분하는데 필요한 정보

- URL-Locator: 리소스가 있는 위치를 지정
- URN-Name: 리소스에 이름을 부여

### 구조

scheme://[userinfo@]host[:port][/path][?query][#fragment]

scheme: 주로 프로토콜 사용(http, https, ftp)
    - 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
    - http는 80 포트, https는 443 포트를 주로 사용, 포트 생략 가능

userinfo: 거의 사용하지 않음, URL에 사용자 정보를 포함해서 인증해야 할 때 사용

host: 도메인 명, IP 주소 입력

port: 생략 가능, 생략시 http는 80, https는 443 -> 특정 포트로 들어가야할 땐 입력

path: 리소스가 있는 경로, 계층적 구조

query: 
    - key=value 형태
    - ?로 시작하고 &으로 추가 가능
    - query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태

## 웹 브라우저 요청 흐름

1. 주소 입력
2. DNS 조회
3. IP와 포트 정보 찾아서 HTTP 요청 메시지 생성
> GET /search?q=hello&hl=ko HTTP/1.1 </br> Host: www.google.com
4. SOCKET 라이브러리를 통해 전달(TCP/IP 연결)

# 섹션 1 HTTP 기본

## 모든 것이 HTTP

HyperText Transfer Protocol

HTTP 메시지에 모든 것을 전송 가능

HTTP/1.1 1997년 버전에 가장 많은 기능이 있고, 우리에게 가장 중요한 버전(가장 많이 사용)

뒤에는 성능개선

클라이언트 - 서버 구조로 동작

무상태 프로토콜(Stateless) 비연결성

HTTP 메시지

단순함, 확장 가능

## 클라이언트 서버 구조

클라이언트와 서버가 각각 독립적(서버는 데이터, 클라이언트는 UI 화면 등)

## Stateful, Stateless 차이

어떠한 정보의 상태를 유지하는 것의 차이

상태 유지: 중간에 다른 점원으로 바뀌면 안된다(바뀌면 상태 정보를 알려줘야 한다)

무상태: 중간에 바뀌어도 된다

무상태는 응답 서버를 쉽게 바꿀 수 있다

Stateful은 항상 같은 서버가 유지되어야 한다

Stateless는 아무 서버나 호출해도 된다(클라이언트에 정보가 있다) -> 스케일 아웃(수평 확장)에 유리

### Stateless의 한계?
- 단순한 서비스 소개 화면(무상태 설계 쉬움, 정보가 필요 없음)
- 상태 유지(로그인) -> 쿠키와 서버 세션 등을 사용해서 상태 유지, 상태 유지는 최소한만 사용

## 비연결성
HTTP는 기본적으로 연결을 유지하지 않는 모델

### 한계와 극복
TCP/IP 연결을 새로 해야하면 3 way handshake 시간 추가

수 많은 자원이 함께 다운로드 된다

지금은 HTTP 지속 연결(persistance connection)로 문제 해결

## HTTP 메시지

### 메시지의 구조

start-line: 시작 라인

header: 헤더

empty line: 공백 라인(CRLF)

message body

### 시작 라인 - 요청 메시지
#### HTTP 메서드

종류: GET, POST, DELETE, PUT ...

서버가 수행해야 할 동작 지정
- GET: 리소스 조회
- POST: 요청 내역 처리

#### 요청 대상
절대경로[?query]

절대경로 = "/"로 시작하는 경로

#### HTTP 버전

### 응답 메시지

### 시작 라인 - 응답 메시지
start-line = request-line / status-line

status-line = HTTP-version status-code reason-pharse CRLF

HTTP 버전

HTTP 상태 코드: 요청 성공, 실패
- 200: 성공
- 400: 클라이언트 요청 오류
- 500: 서버 내부 오류

이유 문구: 짧은 상태 코드 설명 글

### HTTP 헤더
header-field = field-name ":" OWS field-value OWS

field-name은 대소문자 구분 없음

헤더의 용도: HTTP 전송에 필요한 모든 부가 정보 저장

ex) 메시지 바디 내용, 메시지 바디 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보...

표준 헤더가 매우 많다

임의 헤더 추가도 가능하다

### HTTP 메시지 바디

실제 전송 데이터

byte로 표현 가능한 모든 데이터 전송

# HTTP 메서드

## HTTP API 만들기

### 좋은 URI 설계?
중요한 것은 *리소스 식별*

리소스 의미는 무엇인가?
- 회원 등록 수정 조회가 리소스가 아님
- 회원 정보에선 회원 자체가 리소스

어떻게 식별하는 것이 좋을까?
- 회원 목록 조회: /members
- 회원 조회: /members/{id}
- 회원 등록: /members/{id}
- 회원 수정: /members/{id}
- 회원 삭제: /members/{id}

구별을 어떻게 할 수 있나?

### 리소스와 행위 분리
URI는 리소스만 식별
- 리소스: 멤버
- 행위: 조회, 등록, 삭제, 변경

HTTP 메서드로 행위를 구별한다

우리는 URI의 리소스만 식별하면 된다

## HTTP 메서드 - GET, POST

### GET
GET: 리소스 조회

서버에 전달하고 싶은 데이터는 query를 통해 전달

바디도 가능하지만, 지원하지 않는 곳이 많아 권장하지 않음

### POST
요청 데이터 처리

메시지 바디를 통해 서버로 요청 데이터 전달

바디를 통해 들어온 데이터를 처리하는 모든 기능

신규 리소스 등록, 프로세스 처리 등에 사용

## HTTP 메서드 - PUT, PATCH, DELETE

### PUT
리소스가 있으면 대체 없으면 생성(덮어쓰기)

클라이언트가 리소스를 식별(POST와의 차이점) URI에 입력

완전히 대체하는 것이 중요

Why? 빼먹은 필드는 없어진다... 완전 대체 된다

### PATCH
패치는 부분 변경이 되기 때문에 PUT의 보완? 정도인듯

지원이 안되는 서버도 있다..?!

그럴 경우에는 POST를 사용해야 한다

## HTTP 메서드의 속성

### 안전
호출해도 리소스를 변경하지 않는다

GET만 안전(나머지 메서드는 변경을 일어나게 한다)

서버에 쌓이는 로그 등은 고려하지 않는다. 해당 리소스가 변하는지 여부만 판단한다

### 멱등(Idempotent)
한 번 호출하든 두 번 호출하든 계속 호출하든 결과가 같아야 한다

GET, PUT, DELETE는 멱등하다

POST는 두 번 호출하면 중복 발생한다

활용 -> 자동 복구 메커니즘(서버가 TIMEOUT 등으로 정상 응답이 아닐 때 클라이언트가 다시 요청해도 되는가?)

멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지 고려하지 않는다

### 캐시 가능

응답 결과 리소스를 캐시해서 사용해도 되는가?

GET, HEAD, POST, PATCH 캐시 가능

실제로는 GET, HEAD 정도만 캐시로 사용(캐시 키를 고려해야 하기 때문에 다른 것에는 구현이 쉽지 않아서)

# 섹션 5 HTTP 메서드 활용

## 클라이언트에서 서버로 데이터 전송

## HTTP API 설계 예시