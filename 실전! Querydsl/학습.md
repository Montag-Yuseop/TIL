# 섹션 0 - Querydsl 소개

## 소개

Querydsl은 컴파일 시점에서 오류를 확인할 수 있다

jpql은 실행해 봐야 알 수 있다

코드 자동완성도 사용할 수 있다

동적 쿼리 문제도 해결할 수 있다

메서드화 할 수도 있다(문자열에서 할 수 없었던 일이 가능해진다)

# 섹션 1 - 프로젝트 환경설정

## 프로젝트 생성

Annotation Processors - Enalbe annotation processing 체크(롬복 사용)

### Querydsl 설정

dependencies에 추가 할 내용

```gradle
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"
    annotationProcessor "jakarta.annotation:jakarta.annotation-api"
    annotationProcessor "jakarta.persistence:jakarta.persistence-api"
```

gradle에서 clean을 할 때 generated 부분만 삭제하기 위해 아래에 추가할 사항

```gradle
clean {
    delete file('src/main/generated')
}
```

이렇게 진행한 뒤 gradle -> build -> clean 이후</br>
gradle -> other -> CompileJava를 진행하면

`build/generated/sources/annotationProcessor` 하위에 Q타입의 엔티티가 생성되어있다

compileQuery뭐시기 기능이 없는 것은 id 부분에 추가해주지 않아서 명령어가 생성되지 않았기 때문인 것 같다

Qfile은 깃에 관리하면 안되니까 어디로 빼지 말자 -> 보통 build 폴더는 gitignore에 설정되어있기 때문에 안올라간다

참고로 Transactional은 org.springframework가 기능이 더 많으니까 거기꺼로 사용하자

## H2 DB

`jdbc:h2:~/querydsl` 최초 1회 파일 생성

`jdbc:h2:tcp://localhost/~/querydsl` 이후에는 이렇게 연결

# 섹션 2 - 예제 도메인 모델

## 예제 도메인 모델과 동작확인

`ManyToOne` Type에서는 항상 `ManyToOne(fetch = FetchType.LAZY)`로 지정해 사용하자

Test에서는 `@Commit` 쓰지 말자 -> DB에 안들어가도록 롤백 시켜야한다

# 섹션 3 - 기본 문법

## 시작 - JPQL vs Querydsl

런타임 vs 컴파일

컴파일 시점에서 발생되는게 훨씬 좋은 코드(오류를 찾기가 더 쉽다)

## 기본 Q-Type 활용

별칭을 주는 방식과 기본 인스턴스 방식

Querydsl은 JPQL 빌더 역할을 하는 것 -> JPQL로 변환해서 작동

## 검색 조건 쿼리

- eq
- ne or eq().not()
- isNotNull()
- in
- notIn
- between
- goe -> >=
- gt -> >
- loe -> <=
- lt -> <
- like
- contains -> %${내용}%
- startWith -> ${내용}%

```java
        Member findMember = queryFactory.selectFrom(member)
                .where(member.username.eq("member1")
                        .and(member.age.between(10, 30)))
                .fetchOne();
```

```java
        Member findMember = queryFactory.selectFrom(member)
                .where(
                        member.username.eq("member1"),
                        member.age.between(10, 30)
                )
                .fetchOne();
```

아래 방식은 null을 무시해버린다 -> 동적 쿼리를 깔끔하게 만들 수 있다(아래 방식 선호)

## 정렬

orderBy절을 추가해서 사용하면 된다

`nullsLast()` 또는 `nullsFirst()`를 잘 활용하자

## 페이징

orderBy를 함께 사용하자

`offeset()`은 0부터 시작한다(시작 페이지)

`limit()`로 가져올 개수를 정하자

## 집합

Tuple 형태로 가져오게 된다

실무에서는 DTO로 뽑아서 쓴다
