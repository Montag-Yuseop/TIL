# 섹션 0 - Querydsl 소개

## 소개

Querydsl은 컴파일 시점에서 오류를 확인할 수 있다

jpql은 실행해 봐야 알 수 있다

코드 자동완성도 사용할 수 있다

동적 쿼리 문제도 해결할 수 있다

메서드화 할 수도 있다(문자열에서 할 수 없었던 일이 가능해진다)

# 섹션 1 - 프로젝트 환경설정

## 프로젝트 생성

Annotation Processors - Enalbe annotation processing 체크(롬복 사용)

### Querydsl 설정

dependencies에 추가 할 내용

```gradle
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"
    annotationProcessor "jakarta.annotation:jakarta.annotation-api"
    annotationProcessor "jakarta.persistence:jakarta.persistence-api"
```

gradle에서 clean을 할 때 generated 부분만 삭제하기 위해 아래에 추가할 사항

```gradle
clean {
    delete file('src/main/generated')
}
```

이렇게 진행한 뒤 gradle -> build -> clean 이후</br>
gradle -> other -> CompileJava를 진행하면

`build/generated/sources/annotationProcessor` 하위에 Q타입의 엔티티가 생성되어있다

compileQuery뭐시기 기능이 없는 것은 id 부분에 추가해주지 않아서 명령어가 생성되지 않았기 때문인 것 같다

Qfile은 깃에 관리하면 안되니까 어디로 빼지 말자 -> 보통 build 폴더는 gitignore에 설정되어있기 때문에 안올라간다

참고로 Transactional은 org.springframework가 기능이 더 많으니까 거기꺼로 사용하자

## H2 DB

`jdbc:h2:~/querydsl` 최초 1회 파일 생성

`jdbc:h2:tcp://localhost/~/querydsl` 이후에는 이렇게 연결

# 섹션 2 - 예제 도메인 모델

## 예제 도메인 모델과 동작확인

`ManyToOne` Type에서는 항상 `ManyToOne(fetch = FetchType.LAZY)`로 지정해 사용하자

Test에서는 `@Commit` 쓰지 말자 -> DB에 안들어가도록 롤백 시켜야한다
