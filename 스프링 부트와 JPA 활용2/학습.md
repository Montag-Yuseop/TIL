# 섹션 1 API 개발 기본

## 회원 등록 API

엔티티를 컨트롤러에서 그대로 파라미터로 받아서 사용하지 말자

-> 나중에 큰 오류가 생길 수 있다!(API 스펙이 바뀌게 되면 다른 여러 곳에서 에러가 생긴다)

따라서 우리는 DTO라는 Data Transfer Object를 이용해 값을 주고 받자

## 회원 수정 API

Command와 Query를 철저히 분리하자

update를 하면서 return type으로 엔티티를 반환하는 것보다는 분리해서 사용하는 것이 유지보수에 좋다

## 회원 조회 API

엔티티를 그대로 노출시키면, 원하지 않는 정보까지 모두 노출되버린다

따라서 조회에서도 필요한 부분만 DTO에 담아서 반환하자

또한 클라이언트마다 요구하는 정보가 다르기 때문에, 엔티티에서 이걸 처리하는 순간 엔티티의 역할을 하지 못한다. 수정도 힘들어진다

# 섹션 2 - API 개발 고급 - 준비

## API 개발 고급 소개

데이터 셈플 입력

지연 로딩과 조회 성능 최적화(N+1 문제)

컬렉션 조회 최적화

페이징 한계 돌파

OSIV와 성능 최적화

순으로 진행

## 조회용 샘플 데이터 입력

# 섹션 3 - API 개발 고급 - 지연 로딩과 조회 성능 최적화

## 엔티티를 직접 노출(JsonIgnore를 활용)

무한 루프에 빠지는 경우 => 양방향 연관관계일 때 엔티티를 직접 조회하면 무한 루프에 빠지는 경우가 생긴다

양방향 걸리는 것 중 하나를 `@JsonIgnore`로 처리해주면 새로운 에러가 나온다

why? 지연 로딩

지연 로딩을 설정해놓으면, Hibernate가 Proxy를 상속받아서 임시로 만들어 놓는다(ByteBuddyIntercepter)

Hibernate5Module을 설치하는 방법이 있다(Jackson DataType Hibernate5)

엔티티를 노출하는 것이 안 좋은 방법이지만, 혹시나 하게 될 경우의 방법이다

엔티티를 직접 가져오게 되면, 불필요한 쿼리문도 계속 호출된다

모든 정보를 긁어오기 때문에 불필요하고, 성능상 좋지 않다

DTO도 간단한 형태로 만들어서 반환하자

그런데 LAZY가 아니라 EAGER로 사용하면 불필요한 코드 없이 실행이 된다?

## 엔티티를 DTO로 변환

새로운 DTO 클래스를 생성해서, stream을 활용해 담아서 반환

API 스펙에 맞추어 반환할 수 있다

LAZY 로딩으로 인한 쿼리 호출에 대한 문제가 있다

ORDER -> SQL 1번 -> 결과 주문 2개(주문 총 수를 가져온다)

루프를 그럼 2번 돌게 된다

### N + 1 문제?(1 + N 문제)

첫 쿼리 실행 결과로 N개를 가져오면, N번만큼 쿼리가 추가로 실행된다

1 + 회원 N + 배송 N(1 + 2 + 2) => 5번 돈다
(주문 가져오는 쿼리1, 회원 2명 조회 쿼리, 회원마다 주소 조회하는 쿼리 한 번씩)

EAGER로 바꿔도 쿼리 최적화는 안된다, 오히려 예측 안되는 쿼리가 나온다

최악의 경우 1 + N + N과 같이, 최악의 경우라고 표현하는 이유는 지연 로딩이 영속성 컨텍스트 부터 확인해보기 때문에 이미 조회된 경우 생략하기 때문이다

## Fetch 조인 최적화

쿼리문을 줄여서 성능을 최적화 하기 위해

```java
return em.createQuery(
    "select o from Order o" +
    " join fetch o.member m" +
    " join fetch o.delivery d", Order.class
).getResultList();
```

이런 형태의 쿼리문을 날려서 `List<Order>`를 반환한다

LAZY를 무시하고 객체 값을 다 채워서 가져온다

Fetch Join하니까 쿼리가 한 번 나간다

## JPA에서 DTO로 바로 조회

```java
return em.createQuery(
    "select new jpabook.jpashop.repository.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address)" +
    " from Order o" +
    " join fetch o.member m" +
    " join fetch o.delivery d", Order.class
).getResultList();
```

DTO에 생성자도 만들어 주어야 한다

```java
@Data
pulbic class OrderSimpleQueryDto {
    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;

    public OrderSimpleQueryDto(Long orderId, String name, LocalDatetime orderDate, OrderStatus orderStatus, Address address) {
        this.orderId = orderId;
        this.name = name;
        this.orderDate = orderDate;
        this.orderStatus = orderStatus;
        this.Address = address;
    }
}

```

쿼리문의 select절이 내가 원하는 부분만 나온다

fetch join에서 불필요하게 조회하는 select절이 줄어든다

하지만 fetch join과 dto로 변환 조회는 더 좋은 것이 정해져있지 않다

로직 재활용은 불가능하지만, 성능적으로는 후자가 더 낫다

엔티티 조회는 데이터를 변경할 수 있지만 DTO 조회는 변경할 수 없다

DTO 조회용은 새로운 레파지토리를 생성해서 사용한다(재사용 불가능하기 때문에 따로 관리)

### 쿼리 방식 선택 권장 순서

- 엔티티를 DTO로 변환하는 방법을 선택한다
- 필요하면 Fetch Join으로 성능을 최적화 한다 -> 대부분 성능 이슈가 해결
- 그래도 안되면 DTO로 직접 조회하는 방법을 사용한다
- 최후의 방법은 네이티브 SQL이나 JDBC 템플릿을 사용해 SQL을 직접 사용한다
