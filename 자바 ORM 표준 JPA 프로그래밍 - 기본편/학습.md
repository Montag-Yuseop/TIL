# 1. JPA 소개

## SQL 중심적인 개발의 문제점

객체 지향 - 관계형 DB

객체 -> 관계형 DB에 보관 / 관리

SQL 중심적인 개발의 문제점
- 쿼리가 너무 많다
- 객체 필드를 추가하면 쿼리문을 다 고쳐야한다
- SQL에 의존적인 개발

하지만 우리는 객체를 관계형 데이터베이스에 저장해야 한다</br>
마땅한 대안이 없다

### 객체와 관계형 데이터 베이스의 차이

- 상속</br>
슈퍼타입-서브타입 관계</br>
계속 조인 쿼리로 가져와야 한다

- 연관 관계</br>
객체는 참조를 사용: member.getTeam()</br>
테이블은 외래 키를 사용: JOIN ON M.TEAM_ID = T.TEAM_ID

- 데이터 타입

- 데이터 식별 방법

## JPA 소개

### ORM?
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 DB는 관계형 DB 대로
- ORM 프레임워크가 이 사이의 패러다임 불일치 등을 매핑해준다

JPA는 애플리케이션과 JDBC 사이에서 동작

### JPA는 표준 명세
- JPA는 인터페이스의 모음

### 왜 JPA를 사용해야 하는가?
- SQL 중심 개발 -> 객체 중심 개발</br>
저장: jpa.persist(member)</br>
조회: Member member = jpa.find(memberId)</br>
수정: member.setName("변경")</br>
삭제: jpa.remove(member)

- 생산성

- 유지 보수

- 패러다임 불일치 해결

- 성능

- 데이터 접근 추상화와 벤더 독립성

- 표준

### JPA와 패러다임 불일치 해결
- 상속:</br>
개발자가 짜던 많은 쿼리들을 JPA가 처리해준다

- 연관관계:</br>

- 객체 그래프 탐색:</br>
엔티티 계층 신뢰(동일 트랜잭션에서 조회한 엔티티는 동일함을 보장한다)

- 비교하기

### 성능 최적화
- 1차 캐시와 동일성 보장:</br>
동일한 엔티티를 조회하면, JPA 메모리에 저장했던 엔티티를 가져와서 동일성을 보장한다</br>
속도도 빨라짐(동일한 트랜잭션 내에서만)

- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind): </br>
트랜잭션을 커밋할 때 까지 INSERT SQL을 모았다가 한번에 SQL 전송

- 지연 로딩(Lazy Loading):</br>
지연 로딩: 객체가 실제 사용될 때 로딩</br>
즉시 로딩: JOIN SQL로 한 번에 연관된 객체까지 미리 조회

