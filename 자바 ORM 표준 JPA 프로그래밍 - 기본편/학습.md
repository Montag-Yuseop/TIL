# 1. JPA 소개

## SQL 중심적인 개발의 문제점

객체 지향 - 관계형 DB

객체 -> 관계형 DB에 보관 / 관리

SQL 중심적인 개발의 문제점
- 쿼리가 너무 많다
- 객체 필드를 추가하면 쿼리문을 다 고쳐야한다
- SQL에 의존적인 개발

하지만 우리는 객체를 관계형 데이터베이스에 저장해야 한다</br>
마땅한 대안이 없다

### 객체와 관계형 데이터 베이스의 차이

- 상속</br>
슈퍼타입-서브타입 관계</br>
계속 조인 쿼리로 가져와야 한다

- 연관 관계</br>
객체는 참조를 사용: member.getTeam()</br>
테이블은 외래 키를 사용: JOIN ON M.TEAM_ID = T.TEAM_ID

- 데이터 타입

- 데이터 식별 방법

## JPA 소개

### ORM?
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 DB는 관계형 DB 대로
- ORM 프레임워크가 이 사이의 패러다임 불일치 등을 매핑해준다

JPA는 애플리케이션과 JDBC 사이에서 동작

### JPA는 표준 명세
- JPA는 인터페이스의 모음

### 왜 JPA를 사용해야 하는가?
- SQL 중심 개발 -> 객체 중심 개발</br>
저장: jpa.persist(member)</br>
조회: Member member = jpa.find(memberId)</br>
수정: member.setName("변경")</br>
삭제: jpa.remove(member)

- 생산성

- 유지 보수

- 패러다임 불일치 해결

- 성능

- 데이터 접근 추상화와 벤더 독립성

- 표준

### JPA와 패러다임 불일치 해결
- 상속:</br>
개발자가 짜던 많은 쿼리들을 JPA가 처리해준다

- 연관관계:</br>

- 객체 그래프 탐색:</br>
엔티티 계층 신뢰(동일 트랜잭션에서 조회한 엔티티는 동일함을 보장한다)

- 비교하기

### 성능 최적화
- 1차 캐시와 동일성 보장:</br>
동일한 엔티티를 조회하면, JPA 메모리에 저장했던 엔티티를 가져와서 동일성을 보장한다</br>
속도도 빨라짐(동일한 트랜잭션 내에서만)

- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind): </br>
트랜잭션을 커밋할 때 까지 INSERT SQL을 모았다가 한번에 SQL 전송

- 지연 로딩(Lazy Loading):</br>
지연 로딩: 객체가 실제 사용될 때 로딩</br>
즉시 로딩: JOIN SQL로 한 번에 연관된 객체까지 미리 조회

# 영속성 관리 - 내부 동작 방식

## 영속성 컨텍스트
엔티티를 영구 저장하는 환경

```EntityManager.persist(entity);```</br>

## 플러시

플러시? 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

쿼리를 DB로 날리는 것

### 플러시 발생

변경 감지(더티 체킹)

수정된 엔티티 쓰기 지연 SQL 저장소에 등록

쓰기 지연 SQL 저장소 쿼리를 DB에 전송(등록, 수정, 삭제 쿼리)

### 영속성 컨텍스트를 플러시하는 방법

- em.flush(): 직접 호출

- 트랜잭션 커밋: 플러시 자동 호출

- JPQL 쿼리 실행: 플러시 자동 호출

### 플러시

영속성 컨텍스트의 쓰기 지연 SQL 저장소의 SQL 쿼리들을 DB로 바로 반영하는 것

1차 캐시 유효

### 플러시 모드 옵션(쓸 일은 없다)
```em.setFlushMode(FlushModeType.COMMIT)```
- FlushModeType.AUTO: 커밋, 쿼리 실행할 때 플러시(기본 값)
- FlushModeType.COMMIT: 커밋할 때만 플러시

## 준영속 상태
JPA가 관리하는 상태 -> 1차 캐시에서 관리: 영속 상태

### 준영속 상태로 만드는 방법

- detach(): 특정 엔티티만 준영속 상태로
- clear(): 영속성 컨텍스트 초기화
- close(): 영속성 컨텍스트 종료

# 엔티티 매핑

## 객체와 테이블 매핑

### 엔티티 매핑
- 객체와 테이블 매핑: @Entity, @Table
- 필드와 컬럼: @Column
- 기본 키: @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn

### @Entity
JPA가 관리

JPA를 사용해서 테이블과 매핑하려면 @Entity 필수

기본 생성자 필수(public or protected)

- create: 기존 테이블 삭제 후 다시 생성(DROP + CREATE)

- create-drop: 종료 시점에 DROP 추가

- update: 변경분만 반영(삭제는 반영 안함)

- validate: 엔티티와 테이블 정상 매핑 확인

- none: 사용하지 않음

운영 장비에는 절대로 create, create-drop, update 사용 금지

- 개발 초기: create or update
- 테스트 서버: update or validate
- 스테이징과 운영 서버: validate or none

## 필드와 컬럼 매핑

### Lob
varchar를 넘는 큰 데이터를 넣을 때 사용?

### Column
- name: 필드와 매핑 테이블 컬럼 이름
- updatable / insertable: 등록, 변경 가능 여부
- nullable(DDL): null 허용 여부
- unique: 간단한 유니크 제약 조건, 이름을 반영하기 어렵기 때문에</br>
Table()에서 거는 것이 낫다(uniqueConstraints)
- columnDefinition: 컬럼 정보 직접
- length: 길이 제약, String만

### Enumerated
EnumType.ORDINAL / EnumType.STRING

ORDINAL은 숫자로 변환하기 때문에 나중에 수정할 때, 순서를 바꾸면 문제가 생긴다</br>
따라서 STRING으로 사용하는 것이 맞다

### Temporal
날짜 타입을 매핑할 때 사용(옛날에는 사용, 요즘엔 안 씀)

최신 버전을 사용할 때는 LocalDate, LocalDateTime을 통해 사용

### Lob
지정 가능한 속성이 없음

문자는 CLOB, 나머지는 BLOB

### Transient
매핑 안할 때 사용

저장도 조회도 되지 않음(메모리에만 저장)

## 기본 키 매핑

### Id, GeneratedValue

Id: 직접 할당

GeneratedValue: 자동 생성
- IDENTITY: 데이터베이스에 위임, MySQL
- SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE, SequenceGenerator 사용
- TABLE: 키 생성용 테이블 사용, 모든 DB, TableGenerator 필요
- AUTO: 방언에 따라 자동 지정, 기본

### 권장하는 식별자 전략
- 기본 키 제약 조건: not null, unique, 불변
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다(대리키를 사용하자)
- 주민등록번호도 기본키로 적절하지 않다
- 권장: Long + 대체키 + 키 생성 전략

# 연관관계 매핑

## 단방향 연관관계

## 양방향 연관관계와 연관관계의 주인
주인: 외래키가 있는 곳을 주인으로

mappedby가 쓰인 곳은 읽기만 가능하다

ManyToOne의 Many쪽이 연관관계의 주인이 된다(외래키를 가지고 있는 녀석)

양방향 연관관계인 경우 양쪽에 다 값을 세팅하는 것이 좋다</br>
em.flush(), em.clear() 로 1차 캐시를 삭제했을 때는 괜찮지만, 1차 캐시 내에 남아있는 경우 제대로 값을 가져오지 못하는 상황이 발생한다

toString과 같은 경우 무한 루프가 걸릴 수 있다
(lombok, toString(), JSON 생성 등)

컨트롤러에서 엔티티를 절대 반환하지 마라</br>
엔티티는 (단순한 값만 있는)DTO로 반환해라

### 양방향 매핑관계 정리

단방향 매핑만으로도 이미 연관관계 매핑 완료(설계는 단방향 매핑으로 완료해야 한다)

양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것

JPQL에서 역방향 탐색할 일이 많음

### 연관관계 주인을 정하는 기준

외래 키의 위치를 기준으로 정해야 한다

비즈니스 로직을 기준으로 연관관계 주인을 정하면 안된다

# 다양한 연관관계 매핑

고려 사항 3가지
- 다중성: 다대일, 일대다, 일대일, 다대다

- 단방향, 양방향:</br>
테이블: 외래 키 하나로 양쪽 조인 가능</br>
객체: 참조용 필드가 있는 쪽으로만 참조 가능

- 연관관계 주인</br>
테이블은 외래키 하나로 두 테이블이 연관관계를 맺음
</br>
객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
</br>
둘 중 테이블 외래 키를 관리할 곳을 지정해야 함
</br>
연관관계의 주인: 외래 키를 관리하는 참조
</br>
주인의 반대편: 외래 키에 영향을 주지않고, 단순 조회만

## 다대일[N:1]

## 일대다[1:N]
엔티티가 관리하는 외래 키가 다른 테이블에 있음

다른 테이블에 업데이트 쿼리를 사용해야 한다

일대다 단방향 매핑보다는 다대일 양방향 매핑 선호

## 일대일[1:1]

주 테이블이나 대상 테이블 중에 외래 키 선택 가능</br>
주 테이블 외래 키</br>
대상 테이블에 외래 키

외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

- 주 테이블에 외래 키</br>
주 객체가 대상 객체의 참조를 가지는 것 처럼, 주 테이블에 외래 키를 두고 대상 테이블을 찾음</br>
객체지향 개발자 선호</br>
JPA 매핑 편리</br>
장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능</br>
단점: 값이 없으면 외래 키에 null 허용

- 대상 테이블에 외래 키: </br>
대상 테이블에 외래 키 존재</br>
전통적인 데이터베이스 개발자 선호</br>
장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지</br>
단점: 프록시 기능의 한계로 지연 로딩을 해도 항상 즉시 로딩

## 다대다[N:N]

ManyToMany를 사용하게 되면 가운데 새로운 연결 테이블이 생긴다

이 연결 테이블을 엔티티로 승격시켜 사용한다

그리고 한쪽은 OneToMany, 다른 쪽은 ManyToOne을 걸어놓고

새로 class를 하나 만들어 사용한다

# 고급 매핑

## 상속관계 매핑

관계형 데이터베이스는 상속 관계 X

슈퍼타입 서브타입 관계 모델링 기법이 객체 상속과 유사

## 조인 전략
@DiscriminatorColumn(name = "") 을 통해 어떤 테이블에서 조인되는지 알 수 있게 한다</br>
name을 생략하면 DTYPE 컬럼이 되고, 아니면 name에 넣은 이름으로 바뀐다

자식 클래스에서는 @DiscriminatorValue("A") 와 같은 형식으로 변경 가능하다
