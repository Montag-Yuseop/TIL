# 1. JPA 소개

## SQL 중심적인 개발의 문제점

객체 지향 - 관계형 DB

객체 -> 관계형 DB에 보관 / 관리

SQL 중심적인 개발의 문제점
- 쿼리가 너무 많다
- 객체 필드를 추가하면 쿼리문을 다 고쳐야한다
- SQL에 의존적인 개발

하지만 우리는 객체를 관계형 데이터베이스에 저장해야 한다</br>
마땅한 대안이 없다

### 객체와 관계형 데이터 베이스의 차이

- 상속</br>
슈퍼타입-서브타입 관계</br>
계속 조인 쿼리로 가져와야 한다

- 연관 관계</br>
객체는 참조를 사용: member.getTeam()</br>
테이블은 외래 키를 사용: JOIN ON M.TEAM_ID = T.TEAM_ID

- 데이터 타입

- 데이터 식별 방법

## JPA 소개

### ORM?
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 DB는 관계형 DB 대로
- ORM 프레임워크가 이 사이의 패러다임 불일치 등을 매핑해준다

JPA는 애플리케이션과 JDBC 사이에서 동작

### JPA는 표준 명세
- JPA는 인터페이스의 모음

### 왜 JPA를 사용해야 하는가?
- SQL 중심 개발 -> 객체 중심 개발</br>
저장: jpa.persist(member)</br>
조회: Member member = jpa.find(memberId)</br>
수정: member.setName("변경")</br>
삭제: jpa.remove(member)

- 생산성

- 유지 보수

- 패러다임 불일치 해결

- 성능

- 데이터 접근 추상화와 벤더 독립성

- 표준

### JPA와 패러다임 불일치 해결
- 상속:</br>
개발자가 짜던 많은 쿼리들을 JPA가 처리해준다

- 연관관계:</br>

- 객체 그래프 탐색:</br>
엔티티 계층 신뢰(동일 트랜잭션에서 조회한 엔티티는 동일함을 보장한다)

- 비교하기

### 성능 최적화
- 1차 캐시와 동일성 보장:</br>
동일한 엔티티를 조회하면, JPA 메모리에 저장했던 엔티티를 가져와서 동일성을 보장한다</br>
속도도 빨라짐(동일한 트랜잭션 내에서만)

- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind): </br>
트랜잭션을 커밋할 때 까지 INSERT SQL을 모았다가 한번에 SQL 전송

- 지연 로딩(Lazy Loading):</br>
지연 로딩: 객체가 실제 사용될 때 로딩</br>
즉시 로딩: JOIN SQL로 한 번에 연관된 객체까지 미리 조회

# 영속성 관리 - 내부 동작 방식

## 영속성 컨텍스트
엔티티를 영구 저장하는 환경

```EntityManager.persist(entity);```</br>

## 플러시

플러시? 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

쿼리를 DB로 날리는 것

### 플러시 발생

변경 감지(더티 체킹)

수정된 엔티티 쓰기 지연 SQL 저장소에 등록

쓰기 지연 SQL 저장소 쿼리를 DB에 전송(등록, 수정, 삭제 쿼리)

### 영속성 컨텍스트를 플러시하는 방법

- em.flush(): 직접 호출

- 트랜잭션 커밋: 플러시 자동 호출

- JPQL 쿼리 실행: 플러시 자동 호출

### 플러시

영속성 컨텍스트의 쓰기 지연 SQL 저장소의 SQL 쿼리들을 DB로 바로 반영하는 것

1차 캐시 유효

### 플러시 모드 옵션(쓸 일은 없다)
```em.setFlushMode(FlushModeType.COMMIT)```
- FlushModeType.AUTO: 커밋, 쿼리 실행할 때 플러시(기본 값)
- FlushModeType.COMMIT: 커밋할 때만 플러시

## 준영속 상태
JPA가 관리하는 상태 -> 1차 캐시에서 관리: 영속 상태

### 준영속 상태로 만드는 방법

- detach(): 특정 엔티티만 준영속 상태로
- clear(): 영속성 컨텍스트 초기화
- close(): 영속성 컨텍스트 종료

# 엔티티 매핑

## 객체와 테이블 매핑

### 엔티티 매핑
- 객체와 테이블 매핑: @Entity, @Table
- 필드와 컬럼: @Column
- 기본 키: @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn

### @Entity
JPA가 관리

JPA를 사용해서 테이블과 매핑하려면 @Entity 필수

기본 생성자 필수(public or protected)

- create: 기존 테이블 삭제 후 다시 생성(DROP + CREATE)

- create-drop: 종료 시점에 DROP 추가

- update: 변경분만 반영(삭제는 반영 안함)

- validate: 엔티티와 테이블 정상 매핑 확인

- none: 사용하지 않음

운영 장비에는 절대로 create, create-drop, update 사용 금지

- 개발 초기: create or update
- 테스트 서버: update or validate
- 스테이징과 운영 서버: validate or none

## 필드와 컬럼 매핑

### Lob
varchar를 넘는 큰 데이터를 넣을 때 사용?

### Column
- name: 필드와 매핑 테이블 컬럼 이름
- updatable / insertable: 등록, 변경 가능 여부
- nullable(DDL): null 허용 여부
- unique: 간단한 유니크 제약 조건, 이름을 반영하기 어렵기 때문에</br>
Table()에서 거는 것이 낫다(uniqueConstraints)
- columnDefinition: 컬럼 정보 직접
- length: 길이 제약, String만

### Enumerated
EnumType.ORDINAL / EnumType.STRING

ORDINAL은 숫자로 변환하기 때문에 나중에 수정할 때, 순서를 바꾸면 문제가 생긴다</br>
따라서 STRING으로 사용하는 것이 맞다

### Temporal
날짜 타입을 매핑할 때 사용(옛날에는 사용, 요즘엔 안 씀)

최신 버전을 사용할 때는 LocalDate, LocalDateTime을 통해 사용

### Lob
지정 가능한 속성이 없음

문자는 CLOB, 나머지는 BLOB

### Transient
매핑 안할 때 사용

저장도 조회도 되지 않음(메모리에만 저장)
