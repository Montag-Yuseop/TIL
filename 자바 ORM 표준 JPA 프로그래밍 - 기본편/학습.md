# 1. JPA 소개

## SQL 중심적인 개발의 문제점

객체 지향 - 관계형 DB

객체 -> 관계형 DB에 보관 / 관리

SQL 중심적인 개발의 문제점
- 쿼리가 너무 많다
- 객체 필드를 추가하면 쿼리문을 다 고쳐야한다
- SQL에 의존적인 개발

하지만 우리는 객체를 관계형 데이터베이스에 저장해야 한다</br>
마땅한 대안이 없다

### 객체와 관계형 데이터 베이스의 차이

- 상속</br>
슈퍼타입-서브타입 관계</br>
계속 조인 쿼리로 가져와야 한다

- 연관 관계</br>
객체는 참조를 사용: member.getTeam()</br>
테이블은 외래 키를 사용: JOIN ON M.TEAM_ID = T.TEAM_ID

- 데이터 타입

- 데이터 식별 방법

## JPA 소개

### ORM?
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 DB는 관계형 DB 대로
- ORM 프레임워크가 이 사이의 패러다임 불일치 등을 매핑해준다

JPA는 애플리케이션과 JDBC 사이에서 동작

### JPA는 표준 명세
- JPA는 인터페이스의 모음

### 왜 JPA를 사용해야 하는가?
- SQL 중심 개발 -> 객체 중심 개발</br>
저장: jpa.persist(member)</br>
조회: Member member = jpa.find(memberId)</br>
수정: member.setName("변경")</br>
삭제: jpa.remove(member)

- 생산성

- 유지 보수

- 패러다임 불일치 해결

- 성능

- 데이터 접근 추상화와 벤더 독립성

- 표준

### JPA와 패러다임 불일치 해결
- 상속:</br>
개발자가 짜던 많은 쿼리들을 JPA가 처리해준다

- 연관관계:</br>

- 객체 그래프 탐색:</br>
엔티티 계층 신뢰(동일 트랜잭션에서 조회한 엔티티는 동일함을 보장한다)

- 비교하기

### 성능 최적화
- 1차 캐시와 동일성 보장:</br>
동일한 엔티티를 조회하면, JPA 메모리에 저장했던 엔티티를 가져와서 동일성을 보장한다</br>
속도도 빨라짐(동일한 트랜잭션 내에서만)

- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind): </br>
트랜잭션을 커밋할 때 까지 INSERT SQL을 모았다가 한번에 SQL 전송

- 지연 로딩(Lazy Loading):</br>
지연 로딩: 객체가 실제 사용될 때 로딩</br>
즉시 로딩: JOIN SQL로 한 번에 연관된 객체까지 미리 조회

## 영속성 관리 - 내부 동작 방식

### 영속성 컨텍스트
엔티티를 영구 저장하는 환경

```EntityManager.persist(entity);```</br>


### 플러시

플러시? 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

쿼리를 DB로 날리는 것

#### 플러시 발생

변경 감지(더티 체킹)

수정된 엔티티 쓰기 지연 SQL 저장소에 등록

쓰기 지연 SQL 저장소 쿼리를 DB에 전송(등록, 수정, 삭제 쿼리)

#### 영속성 컨텍스트를 플러시하는 방법

- em.flush(): 직접 호출

- 트랜잭션 커밋: 플러시 자동 호출

- JPQL 쿼리 실행: 플러시 자동 호출

#### 플러시

영속성 컨텍스트의 쓰기 지연 SQL 저장소의 SQL 쿼리들을 DB로 바로 반영하는 것

1차 캐시 유효

#### 플러시 모드 옵션(쓸 일은 없다)
```em.setFlushMode(FlushModeType.COMMIT)```
- FlushModeType.AUTO: 커밋, 쿼리 실행할 때 플러시(기본 값)
- FlushModeType.COMMIT: 커밋할 때만 플러시

### 준영속 상태
JPA가 관리하는 상태 -> 1차 캐시에서 관리: 영속 상태

#### 준영속 상태로 만드는 방법

- detach(): 특정 엔티티만 준영속 상태로
- clear(): 영속성 컨텍스트 초기화
- close(): 영속성 컨텍스트 종료


