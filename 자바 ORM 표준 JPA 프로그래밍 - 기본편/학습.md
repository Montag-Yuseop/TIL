# 1. JPA 소개

## SQL 중심적인 개발의 문제점

객체 지향 - 관계형 DB

객체 -> 관계형 DB에 보관 / 관리

SQL 중심적인 개발의 문제점
- 쿼리가 너무 많다
- 객체 필드를 추가하면 쿼리문을 다 고쳐야한다
- SQL에 의존적인 개발

하지만 우리는 객체를 관계형 데이터베이스에 저장해야 한다</br>
마땅한 대안이 없다

### 객체와 관계형 데이터 베이스의 차이

- 상속</br>
슈퍼타입-서브타입 관계</br>
계속 조인 쿼리로 가져와야 한다

- 연관 관계</br>
객체는 참조를 사용: member.getTeam()</br>
테이블은 외래 키를 사용: JOIN ON M.TEAM_ID = T.TEAM_ID

- 데이터 타입

- 데이터 식별 방법

## JPA 소개

### ORM?
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 DB는 관계형 DB 대로
- ORM 프레임워크가 이 사이의 패러다임 불일치 등을 매핑해준다

JPA는 애플리케이션과 JDBC 사이에서 동작

### JPA는 표준 명세
- JPA는 인터페이스의 모음

### 왜 JPA를 사용해야 하는가?
- SQL 중심 개발 -> 객체 중심 개발</br>
저장: jpa.persist(member)</br>
조회: Member member = jpa.find(memberId)</br>
수정: member.setName("변경")</br>
삭제: jpa.remove(member)

- 생산성

- 유지 보수

- 패러다임 불일치 해결

- 성능

- 데이터 접근 추상화와 벤더 독립성

- 표준

### JPA와 패러다임 불일치 해결
- 상속:</br>
개발자가 짜던 많은 쿼리들을 JPA가 처리해준다

- 연관관계:</br>

- 객체 그래프 탐색:</br>
엔티티 계층 신뢰(동일 트랜잭션에서 조회한 엔티티는 동일함을 보장한다)

- 비교하기

### 성능 최적화
- 1차 캐시와 동일성 보장:</br>
동일한 엔티티를 조회하면, JPA 메모리에 저장했던 엔티티를 가져와서 동일성을 보장한다</br>
속도도 빨라짐(동일한 트랜잭션 내에서만)

- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind): </br>
트랜잭션을 커밋할 때 까지 INSERT SQL을 모았다가 한번에 SQL 전송

- 지연 로딩(Lazy Loading):</br>
지연 로딩: 객체가 실제 사용될 때 로딩</br>
즉시 로딩: JOIN SQL로 한 번에 연관된 객체까지 미리 조회

# 영속성 관리 - 내부 동작 방식

## 영속성 컨텍스트
엔티티를 영구 저장하는 환경

```EntityManager.persist(entity);```</br>

## 플러시

플러시? 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

쿼리를 DB로 날리는 것

### 플러시 발생

변경 감지(더티 체킹)

수정된 엔티티 쓰기 지연 SQL 저장소에 등록

쓰기 지연 SQL 저장소 쿼리를 DB에 전송(등록, 수정, 삭제 쿼리)

### 영속성 컨텍스트를 플러시하는 방법

- em.flush(): 직접 호출

- 트랜잭션 커밋: 플러시 자동 호출

- JPQL 쿼리 실행: 플러시 자동 호출

### 플러시

영속성 컨텍스트의 쓰기 지연 SQL 저장소의 SQL 쿼리들을 DB로 바로 반영하는 것

1차 캐시 유효

### 플러시 모드 옵션(쓸 일은 없다)
```em.setFlushMode(FlushModeType.COMMIT)```
- FlushModeType.AUTO: 커밋, 쿼리 실행할 때 플러시(기본 값)
- FlushModeType.COMMIT: 커밋할 때만 플러시

## 준영속 상태
JPA가 관리하는 상태 -> 1차 캐시에서 관리: 영속 상태

### 준영속 상태로 만드는 방법

- detach(): 특정 엔티티만 준영속 상태로
- clear(): 영속성 컨텍스트 초기화
- close(): 영속성 컨텍스트 종료

# 엔티티 매핑

## 객체와 테이블 매핑

### 엔티티 매핑
- 객체와 테이블 매핑: @Entity, @Table
- 필드와 컬럼: @Column
- 기본 키: @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn

### @Entity
JPA가 관리

JPA를 사용해서 테이블과 매핑하려면 @Entity 필수

기본 생성자 필수(public or protected)

- create: 기존 테이블 삭제 후 다시 생성(DROP + CREATE)

- create-drop: 종료 시점에 DROP 추가

- update: 변경분만 반영(삭제는 반영 안함)

- validate: 엔티티와 테이블 정상 매핑 확인

- none: 사용하지 않음

운영 장비에는 절대로 create, create-drop, update 사용 금지

- 개발 초기: create or update
- 테스트 서버: update or validate
- 스테이징과 운영 서버: validate or none

## 필드와 컬럼 매핑

### Lob
varchar를 넘는 큰 데이터를 넣을 때 사용?

### Column
- name: 필드와 매핑 테이블 컬럼 이름
- updatable / insertable: 등록, 변경 가능 여부
- nullable(DDL): null 허용 여부
- unique: 간단한 유니크 제약 조건, 이름을 반영하기 어렵기 때문에</br>
Table()에서 거는 것이 낫다(uniqueConstraints)
- columnDefinition: 컬럼 정보 직접
- length: 길이 제약, String만

### Enumerated
EnumType.ORDINAL / EnumType.STRING

ORDINAL은 숫자로 변환하기 때문에 나중에 수정할 때, 순서를 바꾸면 문제가 생긴다</br>
따라서 STRING으로 사용하는 것이 맞다

### Temporal
날짜 타입을 매핑할 때 사용(옛날에는 사용, 요즘엔 안 씀)

최신 버전을 사용할 때는 LocalDate, LocalDateTime을 통해 사용

### Lob
지정 가능한 속성이 없음

문자는 CLOB, 나머지는 BLOB

### Transient
매핑 안할 때 사용

저장도 조회도 되지 않음(메모리에만 저장)

## 기본 키 매핑

### Id, GeneratedValue

Id: 직접 할당

GeneratedValue: 자동 생성
- IDENTITY: 데이터베이스에 위임, MySQL
- SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE, SequenceGenerator 사용
- TABLE: 키 생성용 테이블 사용, 모든 DB, TableGenerator 필요
- AUTO: 방언에 따라 자동 지정, 기본

### 권장하는 식별자 전략
- 기본 키 제약 조건: not null, unique, 불변
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다(대리키를 사용하자)
- 주민등록번호도 기본키로 적절하지 않다
- 권장: Long + 대체키 + 키 생성 전략

# 연관관계 매핑

## 단방향 연관관계

## 양방향 연관관계와 연관관계의 주인
주인: 외래키가 있는 곳을 주인으로

mappedby가 쓰인 곳은 읽기만 가능하다

ManyToOne의 Many쪽이 연관관계의 주인이 된다(외래키를 가지고 있는 녀석)

양방향 연관관계인 경우 양쪽에 다 값을 세팅하는 것이 좋다</br>
em.flush(), em.clear() 로 1차 캐시를 삭제했을 때는 괜찮지만, 1차 캐시 내에 남아있는 경우 제대로 값을 가져오지 못하는 상황이 발생한다

toString과 같은 경우 무한 루프가 걸릴 수 있다
(lombok, toString(), JSON 생성 등)

컨트롤러에서 엔티티를 절대 반환하지 마라</br>
엔티티는 (단순한 값만 있는)DTO로 반환해라

### 양방향 매핑관계 정리

단방향 매핑만으로도 이미 연관관계 매핑 완료(설계는 단방향 매핑으로 완료해야 한다)

양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것

JPQL에서 역방향 탐색할 일이 많음

### 연관관계 주인을 정하는 기준

외래 키의 위치를 기준으로 정해야 한다

비즈니스 로직을 기준으로 연관관계 주인을 정하면 안된다

# 다양한 연관관계 매핑

고려 사항 3가지
- 다중성: 다대일, 일대다, 일대일, 다대다

- 단방향, 양방향:</br>
테이블: 외래 키 하나로 양쪽 조인 가능</br>
객체: 참조용 필드가 있는 쪽으로만 참조 가능

- 연관관계 주인</br>
테이블은 외래키 하나로 두 테이블이 연관관계를 맺음
</br>
객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
</br>
둘 중 테이블 외래 키를 관리할 곳을 지정해야 함
</br>
연관관계의 주인: 외래 키를 관리하는 참조
</br>
주인의 반대편: 외래 키에 영향을 주지않고, 단순 조회만

## 다대일[N:1]

## 일대다[1:N]
엔티티가 관리하는 외래 키가 다른 테이블에 있음

다른 테이블에 업데이트 쿼리를 사용해야 한다

일대다 단방향 매핑보다는 다대일 양방향 매핑 선호

## 일대일[1:1]

주 테이블이나 대상 테이블 중에 외래 키 선택 가능</br>
주 테이블 외래 키</br>
대상 테이블에 외래 키

외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

- 주 테이블에 외래 키</br>
주 객체가 대상 객체의 참조를 가지는 것 처럼, 주 테이블에 외래 키를 두고 대상 테이블을 찾음</br>
객체지향 개발자 선호</br>
JPA 매핑 편리</br>
장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능</br>
단점: 값이 없으면 외래 키에 null 허용

- 대상 테이블에 외래 키: </br>
대상 테이블에 외래 키 존재</br>
전통적인 데이터베이스 개발자 선호</br>
장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지</br>
단점: 프록시 기능의 한계로 지연 로딩을 해도 항상 즉시 로딩

## 다대다[N:N]

ManyToMany를 사용하게 되면 가운데 새로운 연결 테이블이 생긴다

이 연결 테이블을 엔티티로 승격시켜 사용한다

그리고 한쪽은 OneToMany, 다른 쪽은 ManyToOne을 걸어놓고

새로 class를 하나 만들어 사용한다

# 고급 매핑

## 상속관계 매핑

관계형 데이터베이스는 상속 관계 X

슈퍼타입 서브타입 관계 모델링 기법이 객체 상속과 유사

## 조인 전략
@DiscriminatorColumn(name = "") 을 통해 어떤 테이블에서 조인되는지 알 수 있게 한다</br>
name을 생략하면 DTYPE 컬럼이 되고, 아니면 name에 넣은 이름으로 바뀐다

자식 클래스에서는 @DiscriminatorValue("A") 와 같은 형식으로 변경 가능하다

장점:
- 테이블 정규화
- 외래키 참조 무결성 제약 조건 활용 가능
- 저장 공간의 효율화

단점:
- 조회시 조인 많이 사용, 성능 저하
- 조회 쿼리 복잡(테이블이 많아져서)
- INSERT QUERY 2번 호출

조인 전략이 정석이라 보고 들어가자(데이터, 설계, 저장 등 모두 고려했을 때)

## 단일 테이블 전략
장점: 
- 조인이 필요 없으므로 조회 성능이 빠름
- 조회 쿼리가 단순

단점:
- 자식 엔티티가 매핑한 컬럼은 Null 값을 허용해야 한다(데이터 무결성 문제)
- 테이블이 커질 수 있고 상황에 따라서는 조인 테이블에 비해 느려질 수 있다(일반적으로는 빠르다)

## 구현 클래스마다 테이블 전략
쓰면 안되는 전략이다

Why? DB 설계자, ORM 설계자 둘 다 추천하지 않음</br>
테이블 사이의 연관이 없기 때문에 통합적으로 뭔가를 할 때 매우 불편하다</br>
새로운 테이블이 추가될 때 통합적인 쿼리도 새로 짜야한다

장점:
- 서브 타입을 명확하게 구분해서 처리할 때 효과적
- not null 제약조건 사용 가능

단점:
- 여러 테이블 한 번에 조회할 때 성능이 느림(UNION ALL)
- 자식 테이블을 통합하기 어려움

## MappedSuperclass - 매핑 정보 상속
BaseEntity(부모 엔티티)에 자주 쓰이는 속성들을 미리 입력</br>
공통 매핑 정보 => id, createdTime, updateTime, ...

createdBy, createdDate, lastModifiedBy, lastModifiedDate 등은 자동으로 설정 가능하다(이벤트 기능)

상속관계 매핑이 아니다

엔티티도 아니다(테이블이 없다)

매핑 정보만 제공한다

em.find로 BaseEntity를 설정할 수 없다

추상 클래스로 사용(public abstract class)

# 프록시와 연관관계 관리

## 프록시
왜 써야 하는가?

em.find(): 데이터베이스에서 실제 엔티티 객체 조회

em.getReference(): 데이터 베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회</br>
껍데기만 있고 속은 없음, id값만 들고 있다</br>

### 프록시 특징
실제 클래스를 상속 받아 만들어짐

실제 클래스와 겉 모양이 같다

이론상 진짜인지 프록시인지 구별 안하고 써도 된다

*프록시 객체는 처음 사용할 때 한 번만 초기화*

*프록시가 실제 엔티티로 바뀌는 것이 아님, 참조 값(traget)이 생기는 것*

타입 체크할 때 ```instance of```로 비교해야 한다, ```==``` 비교는 안된다

그런데 이미 호출된 객체를 다시 ```getReference()```로 가져올 때는 프록시가 아닌 기존 호출된 객체의 타입을 반환한다

준영속 상태(detach, close)일때 프록시를 초기화하면 문제가 발생

강제 초기화 방법(호출 말고): ```Hibernate.initialize(호출 객체)```

JPA 표준에는 강제 초기화가 없어서 호출해야 한다

## 즉시 로딩과 지연 로딩

LAZY: 지연 로딩, 프록시 객체 사용

EAGER: 즉시 로딩, 항상 함께 조회(실무에서는 즉시 로딩 사용 ㄴㄴ)

Why?

- 예상치 못한 SQL 발생(쿼리가 많아지고 조인이 많아져서 성능 안나온다)

- JPQL에서 N + 1 문제 발생

- ManyToOne, OneToOne은 Default 값이 EAGER -> Lazy를 적어줘야 한다

### 지연로딩 활용

모든 연관관계에서 지연 로딩을 사용해라

실무에서 즉시 로딩을 사용하지 마라

JPQL fetch 조인이나 엔티티 그래프 기능을 사용해라

## 영속성 전이(CASCADE)와 고아객체

## CASCADE

부모(Parent) 객체 중심으로 영속성 관리를 하고 싶을 때? -> CASCADE를 사용

ALL 또는 Persist정도로 사용

그러나 해당 객체(Child)가 다른 엔티티와 연관관계를 가진다면? 사용하지 말자

완전히 단일 엔티티에 종속되어 라이프 사이클이 같아진 경우에 사용하자

## 고아 객체

고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동 

```orphanRemoval = true```

OneToOne, OneToMany에서 사용 가능

참조하는 곳이 하나일 때 사용

# 값 타입

## 기본 값 타입

## 임베디드 타입

## 값 타입
불변으로 만들어야 한다(나중에 side effect 막으려면)

## 값 타입의 비교

인스턴스가 달라도 값이 같으면 같은 것

## 값 타입 컬렉션

값 타입을 하나 이상 저장할 때 사용

@ElementCollection, @CollectionTable 사용

컬렉션을 저장하기 위한 별도 테이블이 필요하다

컬렉션을 갈아낄 때, 다 지우고 새로 넣는다...

### 값 타입 컬렉션 대안

일대 다 관계로 고려

엔티티를 만들고 CASCADE + 고아 객체 제거를 통해 사용

# JPQL

테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리

엔티티가 대상

SQL에 의존적이지 않음

객체 지향 SQL

동적 쿼리에 대한 문제가 있다

그 대안으로 Criteria가 등장

```java
CriteriaBuilder cb = em.getCriteriaBuilder(); 사용 준비

CriteriaQuery<Member> query = cb.createQuery(Member.class);

Root<Member> m = query.from(Member.class);

query.select(m).where(cb.equal(m.get("username"), "kim"));

List<Member> resultList = em.createQuery(cq).getResultList();
```

이것도 사용하기 복잡하다, 하지만 동적 쿼리를 짜기에 좋다

SQL 문법 오류는 안나지만, 복잡하고 실용성이 부족하다

Criteria 대신 QueryDsl 사용을 권장한다

```java
QMember m = QMember.member;
List<Member> result = queryFactory
    .select(m)
    .from(m)
    .where(m.name.like("kim"))
    .fetch();
```
컴파일 오류를 잡아줘서 좋다

### QueryDSL

문자가 아닌 자바 코드로 JPQL을 작성

JPQL 빌더 역할

컴파일 시점에서 문법 오류 검출 가능

동적 쿼리 작성이 편리

단순하고 쉽고, 실무 사용 권장

### 네이티브 SQL?

JPQL로 해결할 수 없는 특정 DB에 의존적 기능(오라클)

## 기본 문법과 쿼리 API

JPQL은 객체 지향 쿼리 언어, 엔티티 객체를 대상으로 쿼리

JPQL은 SQL을 추상화해서 특정 DB에 의존적이지 않다

SQL로 변환된다

JPQL은 대소문자를 구별한다(엔티티와 속성)

테이블 이름이 아닌, 엔티티의 이름을 사용

### 파라미터 바인딩
이름과 위치 기준으로 사용할 수 있지만, 위치는 오류날 수 있기 때문에 이름 기준으로 사용(순서 밀리기 등)

## 프로젝션

SELECT에 조회 대상을 지정하는 것

조인 등은 명시적으로 나타내주는 것이 나중에 봤을 때 좋다

임베디드 타입 프로젝션 : 엔티티부터 시작 (m.Address ...)

