# 섹션 0 - 강의 준비

## 실행중인 컨테이너 모두 삭제 하는 방법

### 맥

`docker rm -f $(docker ps -aq)`

### 윈도우

powerShell

`docker ps -aq | ForEach-Object {docker rm -f $_}`

# 섹션 1 - 가상화 기술

## 파트 소개

도커 : 컨테이너 관리를 위한 SW

컨테이너 : 큰 서버를 효율적으로 나누어 사용하기 위한 가상화 기술

서버 - 가상화는 무엇??

Hypervisor vs Container

## 애플리케이션 서버

1. 베어메탈 : 컴퓨터를 구입하고 실행하는 방식(서버 구입 -> OS 설치 -> 소프트웨어 실행)

기업에서 사용하기 비효율적

2. 하이퍼바이저

3. 컨테이너

도커의 방식

## 가상 기술과 하이퍼바이저 가상화 기술

하이퍼바이저는 통역 역할

Guest -> Host 호출할 때 번역하는 역할

- 이 기종 커널 간 요청을 전달
- 가상머신 리소스 할당량 관리

VMware 또는 VirtualBox 등

Kernal이 분리되어 있다(Geust Kernal, Host Kernal)

## 컨테이너 가상화

하이퍼바이저 방식보다 더 선호된다

가볍고 빠르다

커널의 기능으로 자체 격리 환경 조성

LXC(LinuX Containers) 기술

모든 컨테이너는 Host Kernal을 공유한다

하이퍼바이저 방식보다 오버헤드가 더 적다(하드웨어 리소스 사용이 효율적, 속도가 빠름)

Kernal이 독립적인 가상 머신이 보안은 더 뛰어나다

컨테이너는 Host와 동일한 종류의 OS만 실행 가능하다

Docker는 이런 컨테이너를 쉽게 사용할 수 있도록 만들어준다

## Docker

Docker => 컨테이너 플랫폼

컨테이너 플랫폼 = 컨테이너 엔전 + 컨테이너 런타임

### 컨테이너 엔진

사용자 요청을 통해 컨테이너 관리

### 컨테이너 런타임

직접 커널과 통신, 격리된 공간 생성

Docker는 RunC라는 컨테이너 런타임 사용

OCI에서 제정한 CRI 표준 구현

### 아키텍처

클라이언트 - 서버 모델로 사용

클라이언트 -> Docker Deamon(컨테이너 관리)

Docker Deamon은 사용자에게 API 제공

Docker CLI를 통해 API 대신 명령어로 입력할 수 있음

## 컨테이너 실행

### 생성

`docker run -p 80:80 --name hellonginx nginx`

- docker run: 실행
- 80:80: 포트
- hellonginx: 컨테이너 이름
- nginx: 이미지

`Ctrl + c` 로 나올 수 있음

### 삭제

`docker rm hellonginx`

- docker rm : 삭제
- hellonginx : 컨테이너 이름

### 실행 순서도

1. docker run ... nginx

Clinet PC : Host OS

Docker CLI가 명령어를 컨테이너 실행 API로 맞게 만들어 `Docker Deamon`으로 전송

`Docker Deamon`은 요청 분석 후 컨테이너 런타임을 통해 컨테이너 생성

격리된 공간에서 안전한 운영 가능

# 섹션 2 - 이미지와 컨테이너

## 이미지와 컨테이너

`docker image ls`

이미지 목록 보기

`docker image ls ${name}`

name 이름을 가진 이미지 보기

Tag: 버전

Image Id: Image 고유 ID

한 개의 이미지에서 여러개의 컨테이너를 실행할 수 있다

동일한 이미지에서 실행된 컨테이너는 동일한 프로세스로 실행된다

이미지인 상태는 디스크 공간만 차지, 이미지를 컨테이너로 실행해야 CPU, MEMORY를 사용

- 프로세스와의 차이?: 컨테이너라는 격리된 공간이 생성된다

### 하나의 이미지에서 여러개의 컨테이너 실행

`docker run -d --name ${컨테이너 명} ${이미지 명}`

-d: 백그라운드에서 실행

`docker rm -f ${컨테이너 명}`

실행중인 컨테이너는 -f 옵션으로 삭제

## 이미지의 메타데이터

`docker iamge inspect ${이미지 명}` 이미지 메타데이터 조회

`docker container inspect ${이미지 명}` 컨테이너 메타데이터 조회

`docker run ${이미지 명} (${실행 명령})` 컨테이너 실행 시 메타데이터 cmd 덮어 쓰기

`docker run --env KEY=VALUE ${이미지 명}` 컨테이너 실행 시 메타데이터 env 덮어쓰기

## 컨테이너의 라이프사이클

터미널에 `docker create --name tencounter devwikirepo/tencounter`

명령어를 통해 10초 뒤에 종료되는 프로그램을 생성하고

`docker start tencounter`를 수행해 본다

`docker start -i tencounter`를 수행하면 로그가 출력된다

10초 뒤에 `docker ps -a`를 수행해보면 Exited(0)이 되어있다

### HundredCounter

100까지 출력하는 컨테이너를 실행하는데, run으로 해본다

`docker run --name hundredcounter devwikirepo/hundredcounter`

컨테이너 생성과 출력을 같이 한다

이 상태에서 `docker puase hundredcounter`를 입력하면, 작동이 중지되는데, 메모리는 계속 사용중인 상태로 멈춘다

`docker stop hundredcounter`를 수행하면 10초 뒤에 컨테이너를 종료한다

`docker start -i hundredcounter` 명령어를 사용하며, -i 명령어를 사용하면 터미널로 연결된다

이 때 처음부터 수행한다

`docker restart hundredcounter` 명령어를 실행하면 10초 뒤 처음부터 다시 시작한다

이 때는 Exited 되지 않고, Run 상태로 남는다

`docker logs hundredcounter`를 실행하면 1회성의 로그를 출력해준다

이걸 지속하고싶으면 -f 옵션을 추가하여 `docker logs -f hundredcounter`를 입력한다

Ctrl + c로 탈출 가능

# 섹션3 - 이미지 레지스트리

## 이미지 레지스트리

GitHub는 소스코드 공유하는 곳

이미지 레지스트리도 깃허브같은 것

Docker Hub도 이미지 저장하는 곳

이미 저장 공간은 3가지

- 로컬 스토리지(호스트)

- 온라인 스토리지(프라이빗 레지스트리, 퍼블릭 레지스트리)

`docker run nginx`를 수행하면?

먼저 로컬 스토리지에 이미지가 있는지 검색한다 -> 도커를 실행하는 호스트의 특정 폴더

로컬 스토리지에 없으면, 외부에서 이미지 다운로드 받고 실행

다음부터는 로컬 스토리지에서 해당 이미지 실행

도커 허브는 퍼블릭 레지스트리

사내용은 프라이빗 레지스트리

개인만의 레지스트리 사용 방법은 두 가지 있음

- 서버에 레지스트리 설치해서 사용

  - HARBOR
  - DOCKER Private

- 퍼블릭 클라우드의 서비스 사용
  - Amazon ECR
  - Azure Container Registry

### 이미지 네이밍 규칙

`docker run -d -p 80:80 --name hellonginx nginx`

nginx만 쓸 수 있는 이유는 default 값이 있기 때문이다

원래는 모든 정보를 써줘야한다

레지스트리 주소/프로젝트 명/이미지 명:이미지 태그

레지스트리 주소: 어떤 레지스트리를 사용할지 지정, 비어있는 경우 기본값으로 설정된 것이 사용됨

docker를 사용하면? docker hub 주소인 `docker.io`

개인 registry 주소를 사용하려면, `montag.com/` 이런 방법으로 사용해야 함

아무것도 안적으면 `docker.io`가 기본값

docker hub는 가입 사용자 명이 프로젝트 명

프로젝트 명은 다운로드 받을 이미지 이름(이거 생략하면 도커 오피셜 이미지인 library에서 가져옴)

이미지 태그는 이미지 버전(빈 값이면 :latest가 기본값)

`devwikirepo/hundredcounter` 이건 풀로쓰면

`docker.io/devwikirepo/tencounter:latest`

`nginx`는 곧 `docker.io/library/nginx:latest`이다

## 이미지 레지스트리 실습

로컬 스토리지로 이미지 다운로드</br>
`docker pull ${이미지명}`

새로운 이미지명을 만드는 명령어</br>
`docker tag ${기존이미지명} ${추가할이미지명}`

이미지 레지스트리에 이미지 업로드</br>
`docker push ${이미지명}`

docker tag로 이름 바꾸면 이미지 아이디가 같다

### 로그인

`docker login`</br>
이미지 레지스트리 인증 정보 생성

`docker logout`</br>
이미지 레지스트리 인증 정보 삭제

`docker image rm 이미지명`</br>
로컬 스토리지의 이미지 삭제

나는 도커 데스크탑으로 로그인해놔서 따로 인증 절차를 거치지 않았다

`cat ~/.docker/config.json` 명령으로 인증 정보를 확인할 수 있는데,

```bash
{
        "auths": {},
        "credsStore": "desktop",
        "currentContext": "default",
        "plugins": {
                "-x-cli-hints": {
                        "enabled": "true"
                }
        }
}
```
이렇게 빈 칸이 나온다, 아마 login 명령을 치지 않아서 auths에 정보가 안들어간 것 같다

하지만 pull, push는 잘 작동한다

똑같은 이미지 아이디를 가진 파일중 하나를 삭제하면, 그냥 `Untagged`로 끝난다

하지만 나머지 파일도 삭제하면, 실제로 파일을 제거하는 `Delete`까지 수행한다

`docker run -d -p 80:80 --name my-simple-web yuseop/my-simple-web:0.1`

이 명령으로 컨테이너를 생성

도커 이미지 파일을 사용하면, 각각의 다른 운영 환경을 통일할 수 있다


# 섹션 4 - 이미지 빌드

## 이미지와 레이어

## 이미지 커밋

## 이미지 빌드

## 빌드 컨텍스트

## 도커 파일 지시어

## 멀티 스테이지 빌드
