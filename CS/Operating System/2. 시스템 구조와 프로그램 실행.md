# 2. System Structure & Program Execution

하드웨어의 동작과 프로그램들이 어떻게 실행되는지?

## 컴퓨터 시스템 구조

Computer = CPU + 메모리

I/O device = Disk + Keyboard ...

I/O device에는 각 장치를 컨트롤하는 device controller가 붙어있다</br>
해당 device controller의 작업 공간은 local buffer라고 한다

CPU는 메모리의 내용을 읽어서 수행한다

CPU 내에는 메모리보다 빠른 레지스터라는 공간이 있다

mode bit은 사용자 모드와 커널 모드를 구분해준다

CPU는 interrupt line을 통해 다른 작업이 들어왔는지 확인한다

I/O 작업과 같은 느린 작업이 CPU에게 들어오면 CPU는 I/O device에 명령을 넘기고 다시 자기 일을 하러 간다</br>
CPU는 매우 빠른 속도로 일을 처리하기 때문에 놀면 손해다

그런데 이런 CPU에 무한 루프의 작업이 부여되어 다른 작업을 하는 것이 불가능한 경우가 생기면 안된다

따라서 timer는 이러한 무한 루프를 체크하는 역할을 한다

CPU의 제어권을 가져오기 위한 방법(timer)

CPU는 메모리에서 가져온 instruction을 하나씩 실행하다가 interrupt가 걸리면 멈춘다

CPU가 열심히 일하고 있다가 I/O가 필요한 작업이 들어오면</br>
해당 작업을 I/O device controller로 넘기고 다음 메모리 적재된 일을 처리한다</br>
I/O 작업처럼 느린 작업이 완료되면 해당 작업은 CPU로 Interrupt를 보낸다</br>
Interrupt를 받아 멈춘 CPU는 다시 해당 작업을 처리한다

CPU가 Interrupt를 받으면 제어권이 운영체제로 넘어간다

우리가 입출력 등의 명령을 내리면 현재 동작중이던 CPU에 Interrupt 신호가 넘어간다</br>
신호가 넘어가면 CPU는 활동을 멈추고 운영체제로 제어권을 넘긴다</br>
운영체제는 해당 Interrupt를 확인해서 어떤 명령을 수행할지 미리 작성된 시스템 콜을 호출한다</br>
CPU는 해당 시스템 콜을 확인하고 거기에 맞춰 일을 수행한다

이런 흐름같은데?

### Mode bit

컴퓨터의 하드웨어는 매우 작고 소중한데, 우리는 컴퓨터를 막 쓰는 악덕 주인이기 때문에</br>
우리 운영체제는 하드웨어를 사용자로부터 보호할 필요가 있다</br>
사용자가 잘못된 수행을 내렸을 때 다른 프로그램과 운영체제에 피해가 가지 않도록 모드를 나눠 놓았다

이것이 사용자 모드 - 커널 모드의 이중화 구조이다

사용자의 프로그램이 "키보드 입력!"과 같은 명령을 내리면, mode bit은 1에서 0으로 바뀐다</br>
즉 사용자 모드 -> 커널 모드로 전환이 일어난다

커널 모드(= 모니터 모드)는 CPU에서 운영체제가 실행중인 상황이다(mode bit = 0)

사용자 모드는 CPU에서 사용자 프로그램을 실행하고 있는 상황(mode bit = 1)

### Timer

일정 시간 뒤에 운영체제로 제어권을 넘기는 Interrupt를 발생시킨다

시간을 계산할 수도 있다

### Device Controller

I/O 장치유형을 관리하는 작은 CPU (하드웨어 컨트롤)

local buffer라는 공간에 정보를 저장한다

- device driver(장치 구동기): OS에서 장치별 처리 루틴을 저장한 소프트웨어 -> 각 device에 접근할 수 있는 인터페이스 제공</br>
실제 작동은 device controller가 수행한다


### DMA Controller(Direct Memory Access)

직접 메모리 접근 컨트롤러

memory controller는 DMA Controller와 CPU 사이의 충돌을 중재한다

I/O Device가 수시로 CPU에 Interrupt를 걸어버리면, CPU 효율도 안나오고 오버헤드가 너무 커진다

따라서 CPU는 자기 일을 시키고, DMA가 해당 Interrupt를 처리해서 메모리에 적재까지 해준다

그리고 그 일이 끝나면 "CPU님 제가 이 일을 다 했습니다 하하" 하면서 CPU에 보고 한 번 하고 끝낸다

이게 블록 단위 전송 및 인터럽트이다

## I/O의 수행

입출력 명령은 모두 특권 명령이다(커널 모드에서만 실행 가능하다)

사용자 프로그램이 I/O를 하는 방법? => 시스템 콜

운영체제야 이것좀 해줘라고 부탁하면서 운영체제 함수를 호출하는 것(= 시스템 콜)

시스템 콜은 하나의 Interrupt

mode bit이 1인 상태에서 I/O 요청을 수행할 수는 없다

응용 프로그램이 소프트웨어적으로 Interrupt를 걸어서 mode bit을 0으로 전환한다

그럼 CPU가 제어권을 운영체제에게 뺏긴다</br>
이 제어권은 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동한다(인터럽트 핸들러)

운영체제는 해당 요청을 확인해서 CPU한테 그 요청에 맞는 명령을 수행하도록 명령한다

수행이 끝나면 제어권은 시스템 콜의 다음 명령으로 이동한다

I/O를 하기 위한 인터럽트는 두 가지 종류가 다 쓰인다</br>
(소프트웨어 인터럽트로 시스템 콜을 진행하고 하드웨어 인터럽트로 I/O 종료를 알린다)


### 인터럽트(Interrupt)

인터럽트 시점의 레지스터와 PC(Program Counter)를 저장하고 CPU 제어를 인터럽트 처리 루틴에 넘긴다

넓은 의미: 하드웨어 인터럽트 + 소프트웨어 인터럽트

보통은 하드웨어 인터럽트를 인터럽트라고 한다

Trap은 소프트웨어 인터럽트
- Exception: 프로그램이 오류를 범한 경우
- System Call: 프로그램이 커널 함수를 호출하는 경우

인터럽트 처리 루틴: 인터럽트가 무슨 일을 할지 운영체제 내에 코드로 다 저장해놓음

인터럽트 벡터: 해당 인터럽트 처리 루틴 주소를 가지고 있는 메뉴얼</br>
이 인터럽트가 발생하면 요 주소를 참고해서 이동해라! 하면 CPU가 거기 있는 코드를 쭉 실행해서 인터럽트를 처리한다

인터럽트 처리 루틴(= 인터럽트 핸들러): 해당 인터럽트를 처리하는 커널 함수

### 동기식 입출력과 비동기식 입출력

동기식: I/O 요청 후 입출력 작업이 완료된 후에 제어가 사용자 프로그램으로 이동

비동기식: 입출력 종료를 기다리지 않고 제어가 사용자 프로그램으로 넘어감

두 경우 모두 I/O 컨트롤러가 인터럽트를 걸어서 종료를 알린다

### 프로그램 실행(메모리 load)

프로그램은 파일 시스템에 실행 파일 형태로 저장

실행시키면 메모리에 올라가면서 프로세스로 변환!

바로 올라가기 전에 virtual memory(가상 메모리)에 먼저 올라감

각 프로세스에 독자적인 주소 공간이 만들어진다(stack / code / data)

물리적 메모리에 전부 올리지 않고, 필요한 부분만 가상 메모리에서 가져다가 올린다

프로그램이 사라지면 가상 메모리도 사라진다

### 운영체제 커널 주소공간

- code
  - 시스템 콜, 인터럽트 처리 코드
  - 자원 관리 코드
  - 서비스 제공 코드

- data
  - 하드웨어 관리를 위한 자료구조 등
  - 프로세스 관리를 위한 자료구조(PCB)

- stack
  - 프로세스 커널 스택

### 사용자 프로그램이 사용하는 함수

- 사용자 정의 함수: 자기 프로그램에서 정의
- 라이브러리 함수: 가져다 쓴 함수, 실행 파일에 포함
- 커널 함수: 운영체제 프로그램 함수(커널 함수 호출 = 시스템 콜)

