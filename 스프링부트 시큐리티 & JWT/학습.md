# 시큐리티 기본

## 환경설정

WebSecurityConfigAdapter는 deprecated

따라서 filterChain을 등록해주어야 한다

그리고 기존에 사용하던

`http.cors().and().csrf().disable()` 방식 또한 deprecated 되었다

[6.1 버전 deprecated된 함수 목록](https://docs.spring.io/spring-security/site/docs/current/api/deprecated-list.html)

[람다식으로 바뀐 이유](https://docs.spring.io/spring-security/reference/migration-7/configuration.html)

Spring Security 6.1.0 부터는 메서드 체이닝의 사용을 지양하고, 람다식을 통해 함수형으로 설계

```java
package thx.dragon.thxdragon.global.config.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import thx.dragon.thxdragon.global.status.MemberStatus;
import thx.dragon.thxdragon.global.util.CustomResponseUtil;

@Configuration
@EnableWebSecurity
@Slf4j
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        log.debug("debug : filterChain 등록");

        http
                .csrf((csrfConfig) -> csrfConfig.disable()
                )
                .headers((headerConfig) ->
                        headerConfig.frameOptions(frameOptionsConfig ->
                                frameOptionsConfig.disable()
                        )
                )
                .authorizeHttpRequests((authorizeRequests) ->
                        authorizeRequests
                                .requestMatchers("/", "/login/**").permitAll()
                                .requestMatchers(("*/check")).permitAll() // 요청 체크를 위해 남겨놓기
                                .requestMatchers("/messages/**").hasRole(MemberStatus.JOIN.name())
                                .anyRequest().authenticated()
                )
                .exceptionHandling((formLogin) ->
                                formLogin
                                        .disable()
                )
                .logout((logoutConfig) ->
                        logoutConfig.logoutSuccessUrl("/")
                ).exceptionHandling((exceptionHandlingConfig) ->
                        exceptionHandlingConfig.authenticationEntryPoint(((request, response, authException) -> {
                            CustomResponseUtil.fail(response, "로그인을 진행해 주세요.", HttpStatus.UNAUTHORIZED);
                        }
                        )).accessDeniedHandler((request, response, accessDeniedException) -> {
                            CustomResponseUtil.fail(response, "권한 없음", HttpStatus.FORBIDDEN);
                        })
                );

        return http.build();
    }

}

```

antMatchers():</br>
이 메서드는 URL 패턴을 지정하여 해당 패턴에 대한 접근 권한을 설정하는 데 사용됩니다.</br>
Ant 스타일의 패턴을 사용하여 URL을 매칭시킬 수 있습니다.</br>
예를 들어, `antMatchers("/admin/")`**는 "/admin/"으로 시작하는 모든 URL에 대한 접근 권한 설정을 의미합니다.

requestMatchers():</br>
이 메서드는 요청 타입에 따라 URL 패턴을 지정하여 해당 요청 타입에 대한 보안 설정을 할 때 사용됩니다.</br>
요청의 종류는 HTTP 메서드(GET, POST 등)나 서블릿 경로를 기반으로 지정할 수 있습니다.</br>
예를 들어, `requestMatchers(HttpMethod.GET, "/public/")`**는 HTTP GET 요청 중 "/public/"으로 시작하는 URL에 대한 보안 설정을 의미합니다.

antMatchers는 스프링 시큐리티 5.8 이상에서 더 이상 사용되지 않는다 -> requestMatchers를 사용하자

## 로그인

시큐리티가 /login 요청이 오면 인터셉트해 로그인을 진행

로그인 진행이 완료되면, 시큐리티 session을 만든다

오브젝트 타입은 Authentication 타입의 객체를 생성

Authentication 안에 User정보가 있어야 하고, 이 오브젝트는 UserDetails 타입이다

### LoginMember 코드

로그인 된 유저 객체를 꺼내다 쓸 때 사용하나보다~?

``` java

package thx.dragon.thxdragon.global.config.auth;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import thx.dragon.thxdragon.member.entity.Member;

import java.util.ArrayList;
import java.util.Collection;

@Getter
@RequiredArgsConstructor
@AllArgsConstructor
@NoArgsConstructor
public class LoginMember implements UserDetails {

    private static final long serialVersionUID = 1L;

    private Member member;

    // 해당 유저의 권한을 return
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        Collection<GrantedAuthority> collection= new ArrayList<>();
        collection.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                return member.getMemberStatus().name();
            }
        });

        return null;
    }

    @Override
    public String getPassword() {
        return member.getPassword();
    }

    @Override
    public String getUsername() {
        return member.getNickname();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    // 휴면 계정 설정 같은거 할 수 있음
    @Override
    public boolean isEnabled() {
        return true;
    }
}

```

### LoginMemberService

UserDetailsService를 implement한다

시큐리티 설정에서 `loginProcessingUrl("/login")`을 걸어놨다면, 자동으로 loadUserByUsername이 실행된다



## KakaoService 관련

일단 카카오에서 엑세스 토큰 받아오는 방법부터 적어놓는다

[참고 블로그](https://suyeoniii.tistory.com/79)


# 포스트맨 테스트 순서

## 카카오 디벨로퍼스에 앱 등록
생략

## 인가 code 받기

get 방식

주소: https://kauth.kakao.com/oauth/authorize

body: 
- client_id = 카카오 REST API 키
- redirect_uri = 앱에 등록한 redirect 주소
- response_type = code

## access token 받기

주소: https://kauth.kakao.com/oauth/token

body: 
- grant_type = authorization_code
- redirect_uri = 앱에 등록한 redirect 주소
- client_id = 카카오 REST API 키
- code = 인가 code 받기에서 나온 주소창의 코드

결과로 access token과 refresh token을 반환

## 카카오 유저 정보 가져오기

https://kapi.kakao.com/v2/user/me

authorization에 bearer을 선택하고 토큰에 access token을 입력

엑세스 토큰을 얻는 코드 나는 KakaoServiceImpl에 저장하였다

``` java
public String getKakaoAccessToken(String code) {

        log.info("값1 = {}", clientId);
        log.info("값2 = {}", redirectUri);
        String reqURL = "https://kauth.kakao.com/oauth/token";

        String accessToken = "";
        String refreshToken = "";

        try {
            URL url = new URL(reqURL);

            HttpURLConnection conn = (HttpURLConnection) url.openConnection();

            conn.setRequestMethod("POST");
            conn.setDoOutput(true);
            conn.setRequestProperty("Authorization", "Bearer " + code);

            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream()));
            StringBuilder sb = new StringBuilder();
            sb.append("grant_type=authorization_code");
            sb.append("&client_id=").append(clientId); // REST API 키 값
            sb.append("&redirect_uri=").append(redirectUri); // REDIRECT_URI 값
            sb.append("&code=" + code);
            bw.write(sb.toString());
            bw.flush();

            int responseCode = conn.getResponseCode();
            log.info("결과값 코드 = {}", responseCode);

            BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line = "";
            String result = "";

            while ((line = br.readLine()) != null) {
                result += line;
            }
            log.info("response body = {}", result);

            //Gson 라이브러리에 포함된 클래스로 JSON파싱 객체 생성
            JsonParser parser = new JsonParser();
            JsonElement element = parser.parse(result);

            accessToken = element.getAsJsonObject().get("access_token").getAsString();
            refreshToken = element.getAsJsonObject().get("refresh_token").getAsString();

            log.info("access_token = {} ", accessToken);
            log.info("refresh_token = {} ", refreshToken);

            br.close();
            bw.close();

        } catch (IOException e) {
            e.printStackTrace();
        }

        return accessToken;
    }
```

여기서 가져온 정보로 시큐리티에 UserDetails를 내가 수정해야하는 것 같다

시큐리티는 /login 호출이 오면 인터셉트한다. 그리고 loadUserByUsername을 실행한다

그니까 순서가

1. 인가 코드 받기

kauth.kakao.com/oauth/authorize?client_id=${내 아이디}&redirect_uri=${redirect 주소}&response_type=code

요걸 통해서 인가 code를 받는다

2. 엑세스 토큰 받기

https://kauth.kakao.com/oauth/token에 해당 인가 코드를 code로 보내서 엑세스 코드를 받아와야 한다

3. 엑세스 토큰을 헤더에 넣고 보내기

Authorization에 해당 엑세스 코드를 넣으면 카카오 유저 정보가 나온다!


그럼... 스프링 시큐리티가 ~/login을 인터셉터하니까, 여기서 인터셉터해서 code를 받아줘야하는데...

이 때 loadUserByUsername을 통해 진행 될거고?