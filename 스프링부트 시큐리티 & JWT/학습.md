# 시큐리티 기본

## 환경설정

WebSecurityConfigAdapter는 deprecated

따라서 filterChain을 등록해주어야 한다

그리고 기존에 사용하던

`http.cors().and().csrf().disable()` 방식 또한 deprecated 되었다

[6.1 버전 deprecated된 함수 목록](https://docs.spring.io/spring-security/site/docs/current/api/deprecated-list.html)

[람다식으로 바뀐 이유](https://docs.spring.io/spring-security/reference/migration-7/configuration.html)

Spring Security 6.1.0 부터는 메서드 체이닝의 사용을 지양하고, 람다식을 통해 함수형으로 설계

```java
package thx.dragon.thxdragon.global.config.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import thx.dragon.thxdragon.global.status.MemberStatus;
import thx.dragon.thxdragon.global.util.CustomResponseUtil;

@Configuration
@EnableWebSecurity
@Slf4j
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        log.debug("debug : filterChain 등록");

        http
                .csrf((csrfConfig) -> csrfConfig.disable()
                )
                .headers((headerConfig) ->
                        headerConfig.frameOptions(frameOptionsConfig ->
                                frameOptionsConfig.disable()
                        )
                )
                .authorizeHttpRequests((authorizeRequests) ->
                        authorizeRequests
                                .requestMatchers("/", "/login/**").permitAll()
                                .requestMatchers(("*/check")).permitAll() // 요청 체크를 위해 남겨놓기
                                .requestMatchers("/messages/**").hasRole(MemberStatus.JOIN.name())
                                .anyRequest().authenticated()
                )
                .exceptionHandling((formLogin) ->
                                formLogin
                                        .disable()
                )
                .logout((logoutConfig) ->
                        logoutConfig.logoutSuccessUrl("/")
                ).exceptionHandling((exceptionHandlingConfig) ->
                        exceptionHandlingConfig.authenticationEntryPoint(((request, response, authException) -> {
                            CustomResponseUtil.fail(response, "로그인을 진행해 주세요.", HttpStatus.UNAUTHORIZED);
                        }
                        )).accessDeniedHandler((request, response, accessDeniedException) -> {
                            CustomResponseUtil.fail(response, "권한 없음", HttpStatus.FORBIDDEN);
                        })
                );

        return http.build();
    }

}

```

antMatchers():</br>
이 메서드는 URL 패턴을 지정하여 해당 패턴에 대한 접근 권한을 설정하는 데 사용됩니다.</br>
Ant 스타일의 패턴을 사용하여 URL을 매칭시킬 수 있습니다.</br>
예를 들어, `antMatchers("/admin/")`**는 "/admin/"으로 시작하는 모든 URL에 대한 접근 권한 설정을 의미합니다.

requestMatchers():</br>
이 메서드는 요청 타입에 따라 URL 패턴을 지정하여 해당 요청 타입에 대한 보안 설정을 할 때 사용됩니다.</br>
요청의 종류는 HTTP 메서드(GET, POST 등)나 서블릿 경로를 기반으로 지정할 수 있습니다.</br>
예를 들어, `requestMatchers(HttpMethod.GET, "/public/")`**는 HTTP GET 요청 중 "/public/"으로 시작하는 URL에 대한 보안 설정을 의미합니다.

antMatchers는 스프링 시큐리티 5.8 이상에서 더 이상 사용되지 않는다 -> requestMatchers를 사용하자

## 로그인

시큐리티가 /login 요청이 오면 인터셉트해 로그인을 진행

로그인 진행이 완료되면, 시큐리티 session을 만든다

오브젝트 타입은 Authentication 타입의 객체를 생성

Authentication 안에 User정보가 있어야 하고, 이 오브젝트는 UserDetails 타입이다

### LoginMember 코드

로그인 된 유저 객체를 꺼내다 쓸 때 사용하나보다~?

``` java

package thx.dragon.thxdragon.global.config.auth;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import thx.dragon.thxdragon.member.entity.Member;

import java.util.ArrayList;
import java.util.Collection;

@Getter
@RequiredArgsConstructor
@AllArgsConstructor
@NoArgsConstructor
public class LoginMember implements UserDetails {

    private static final long serialVersionUID = 1L;

    private Member member;

    // 해당 유저의 권한을 return
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        Collection<GrantedAuthority> collection= new ArrayList<>();
        collection.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                return member.getMemberStatus().name();
            }
        });

        return null;
    }

    @Override
    public String getPassword() {
        return member.getPassword();
    }

    @Override
    public String getUsername() {
        return member.getNickname();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    // 휴면 계정 설정 같은거 할 수 있음
    @Override
    public boolean isEnabled() {
        return true;
    }
}

```

### LoginMemberService

UserDetailsService를 implement한다

시큐리티 설정에서 `loginProcessingUrl("/login")`을 걸어놨다면, 자동으로 loadUserByUsername이 실행된다



## KakaoService 관련

일단 카카오에서 엑세스 토큰 받아오는 방법부터 적어놓는다

[참고 블로그](https://suyeoniii.tistory.com/79)


# 포스트맨 테스트 순서

## 카카오 디벨로퍼스에 앱 등록
생략

## 인가 code 받기

get 방식

주소: https://kauth.kakao.com/oauth/authorize

body: 
- client_id = 카카오 REST API 키
- redirect_uri = 앱에 등록한 redirect 주소
- response_type = code

## access token 받기

주소: https://kauth.kakao.com/oauth/token

body: 
- grant_type = authorization_code
- redirect_uri = 앱에 등록한 redirect 주소
- client_id = 카카오 REST API 키
- code = 인가 code 받기에서 나온 주소창의 코드

결과로 access token과 refresh token을 반환

## 카카오 유저 정보 가져오기

https://kapi.kakao.com/v2/user/me

authorization에 bearer을 선택하고 토큰에 access token을 입력

엑세스 토큰을 얻는 코드 나는 KakaoServiceImpl에 저장하였다

``` java
public String getKakaoAccessToken(String code) {

        log.info("값1 = {}", clientId);
        log.info("값2 = {}", redirectUri);
        String reqURL = "https://kauth.kakao.com/oauth/token";

        String accessToken = "";
        String refreshToken = "";

        try {
            URL url = new URL(reqURL);

            HttpURLConnection conn = (HttpURLConnection) url.openConnection();

            conn.setRequestMethod("POST");
            conn.setDoOutput(true);
            conn.setRequestProperty("Authorization", "Bearer " + code);

            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream()));
            StringBuilder sb = new StringBuilder();
            sb.append("grant_type=authorization_code");
            sb.append("&client_id=").append(clientId); // REST API 키 값
            sb.append("&redirect_uri=").append(redirectUri); // REDIRECT_URI 값
            sb.append("&code=" + code);
            bw.write(sb.toString());
            bw.flush();

            int responseCode = conn.getResponseCode();
            log.info("결과값 코드 = {}", responseCode);

            BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line = "";
            String result = "";

            while ((line = br.readLine()) != null) {
                result += line;
            }
            log.info("response body = {}", result);

            //Gson 라이브러리에 포함된 클래스로 JSON파싱 객체 생성
            JsonParser parser = new JsonParser();
            JsonElement element = parser.parse(result);

            accessToken = element.getAsJsonObject().get("access_token").getAsString();
            refreshToken = element.getAsJsonObject().get("refresh_token").getAsString();

            log.info("access_token = {} ", accessToken);
            log.info("refresh_token = {} ", refreshToken);

            br.close();
            bw.close();

        } catch (IOException e) {
            e.printStackTrace();
        }

        return accessToken;
    }
```

여기서 가져온 정보로 시큐리티에 UserDetails를 내가 수정해야하는 것 같다

시큐리티는 /login 호출이 오면 인터셉트한다. 그리고 loadUserByUsername을 실행한다

그니까 순서가

1. 인가 코드 받기

`kauth.kakao.com/oauth/authorize?client_id=${내 아이디}&redirect_uri=${redirect 주소}&response_type=code`

요걸 통해서 인가 code를 받는다

2. 엑세스 토큰 받기

https://kauth.kakao.com/oauth/token에 해당 인가 코드를 code로 보내서 엑세스 코드를 받아와야 한다

3. 엑세스 토큰을 헤더에 넣고 보내기

Authorization에 해당 엑세스 코드를 넣으면 카카오 유저 정보가 나온다!


그럼... 스프링 시큐리티가 ~/login을 인터셉터하니까, 여기서 인터셉터해서 code를 받아줘야하는데...

이 때 loadUserByUsername을 통해 진행 될거고?

# 강의 보고 배우기

## Security config 설정

SecurityFilterChain을 만들어준다

http 설정을 진행한다

`http.csrf((auth) -> disable);` : 세션 방식은 세션이 고정이라 csrf 공격을 막아야하지만, JWT 방식은 STATELESS 방식이기 때문에 JWT에서 막아준다

`http.formLogin((auth) -> disable);` : JWT 방식이기 때문에 FormLogin과 httpBasic 방식 모두 disable

다음으로인가작업을 진행한다

```java
http
    .authorizeHttpRequests((auth) -> auth
    .requestMatchers("*/login", "/", "/join").permitAll()
    .anyRequest().authenticated()
    );
```

다음은 세션 설정을 해준다(JWT 방식에서 중요하다)

```
http
    .sessionManagement((session) -> session
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS));
```

해시 암호 검증을 위해 BCryptPasswordEncoder를 빈으로 등록한다

```java
    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        log.info("debug : BCryptPasswordEncoder 빈 등록됨");
        return new BCryptPasswordEncoder();
    }
```

여기까지가 기본 설정이다

## JWT 로그인 필터

Form 로그인 방식을 disable() 했기 때문에, UsernamePasswordAuthenticationFilter를 따로 작성해줘야 한다, 즉 커스텀 필터가 필요하다

LoginFilter라는 이름으로 클래스를 생성하고, UsernamePasswordAuthentificationFilter를 extends 한다

또한 attempAuthhentication 메서드를 오버라이딩 한다

해당 메서드는 인증을 하는 Authentication 타입을 반환한다

응답과 요청을 인자로 받는다

```java
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        return super.attemptAuthentication(request, response);
    }
```

검증에 성공하면

`successfulAuthentication` 메서드를, 실패하면 `unsuccessfulAuthentication` 함수 실행

필터를 만들었으면 securityconfig에 필터를 등록하자

http.addFilterAt()을 진행한다(대체하는 필터이기 때문에)

```java
http
                .addFilterAt(new LoginFilter(), UsernamePasswordAuthenticationFilter.class);
```

그리고 해당 로그인 필터 생성자는 다음과 같다

```java
    public LoginFilter(AuthenticationManager authenticationManager, CustomResponseUtil customResponseUtil){
        super(authenticationManager);
        this.customResponseUtil = customResponseUtil;
        setFilterProcessesUrl("/login");
        this.authenticationManager=authenticationManager;
    }
```

따라서 `addFilterAt()` 안에 `new LoginFilter()`안에 두 가지를 넣어줘야 한다

1. authenticationManager()

여기서 `authenticationManager`는 `AuthenticationConfiguration`를 인자로 받는다

따라서 상단에 `private final AuthenticationConfiguration authenticationConfiguration`을 등록해준다

2. customResponseUtil

커스텀리스폰스는 요청 결과값을 보기 위해 임의로 만든 것이기 때문에 생략해도 상관 없다

대신 생략할거면 LoginFilter 생성자에서도 빼줘야 한다

이제 SecurityConfig의 코드는 다음과 같다

```java
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import thx.dragon.thxdragon.global.config.jwt.LoginFilter;
import thx.dragon.thxdragon.global.util.CustomResponseUtil;

@Configuration
@Slf4j
@RequiredArgsConstructor
@EnableWebSecurity
public class SecurityConfig {

    private final AuthenticationConfiguration authenticationConfiguration;

    private final CustomResponseUtil customResponseUtil;

    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        log.info("debug : BCryptPasswordEncoder 빈 등록됨");
        return new BCryptPasswordEncoder();
    }

    // AuthenticationManger Bean 등록
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception{
        return configuration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        log.info("debug : FilterChain 등록");

        // csrf disable?: 세션 방식이 항상 고정되기 때문에 막아줘야 하지만, JWT가 STATELESS 방식으로 막아준다
        http
                .csrf((auth) -> auth.disable());
        http
                .formLogin((auth) -> auth.disable());
        http
                .httpBasic((auth) -> auth.disable());

        // 인가 작업
        http
                .authorizeHttpRequests((auth) -> auth
                        .requestMatchers("/login", "/", "*/join", "*/check").permitAll()
                        .anyRequest().authenticated()
                );

        http
                .addFilterAt(new LoginFilter(authenticationManager(authenticationConfiguration), customResponseUtil), UsernamePasswordAuthenticationFilter.class);

        // 세션 설정, 중요하다(JWT 방식에서는)
        http
                .sessionManagement((session) -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        log.info("debug : FilterChain 종료");

        return http.build();
    }
```
로그인 필터를 등록해줬더니 드디어... loadUser 어찌구가 실행된다...

하지만 아직 오류다. `attemptAuthentication` 메서드 실행시 아직 오류가 나온다

인가 코드를 받고, 해당 코드를 login 안에 code에 넣어서 보내니까 정보를 받아왔다

그리고 파싱을 통해 카카오 아이디까지 받아왔다

## JWT 원리

JWT는 세 부분으로 나누어져 있다. JSON 타입 토큰이며 문자열 형태

.을 통해 Header, payload, signature 부분으로 나뉜다

- Header: JWT임을 명시, 암호화 알고리즘 명시
- payload: 정보(실제 사용자 정보)
- signature: 암호화 알고리즘

토큰 발급 여부만 확인하고, 암호를 너무 믿으면 안됨

## JWT 유틸

JwtUtil

토큰 payload에 저장될 정보

JWT 구현 메서드
- 생성자
- username 확인
- role 확인
- 만료일 확인

JwtUtil은 Component 어노테이션을 달아준다

최신은 0.12.3 -> 기존 0.11.5 방식과 많이 다르다

우선 yml 파일에 spring.jwt.secret에 값을 넣어준다

다음 JwtUtil 클래스를 생성하고

``` java
    private SecretKey secretKey;

    public JwtUtil(@Value("${spring.jwt.secret}") String secret) {
        secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), Jwts.SIG.HS256.key().build().getAlgorithm());
    }
```

를 입력한다

secret으로 저장한 키를 가져와서 암호화하는 작업을 거친 뒤 SecretKey라는 객체 안에 담아준다

다음은 검증하는 로직을 작성하자

``` java
    public String getUsername(String token) {

        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().get("username", String.class);
    }

    public String getRole(String token) {

        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().get("role", String.class);
    }

    public Boolean isExpired(String token) {

        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().getExpiration().before(new Date());
    }
```

검증에서는 verifyWith 메서드를 사용해서 토큰이 나의 서버에서 생성된 것인가, 키 값이 맞는가 검증</br>
build 타입으로 반환 후</br>
`parseSignedClaims` Claim 확인 후</br>
payload 부분에서 get을 통해 username 키 가져옴

다음은 토큰 생성 메서드

``` java
public String createJwt(String username, String role, Long expiredMs) {

        return Jwts.builder()
                .claim("username", username) // payload에 username
                .claim("role", role) // payload에 role
                .issuedAt(new Date(System.currentTimeMillis())) // 토큰 발행일
                .expiration(new Date(System.currentTimeMillis() + expiredMs)) // 토큰 만료일
                .signWith(secretKey) // 암호화
                .compact(); // 토큰 compact 후 발행
    }
```

claim을 통해 payload에 값을 넣어준다

이후 LoginFilter에 JwtUtil 클래스를 등록한다

``` java
    private final JwtUtil jwtUtil;

    public LoginFilter(AuthenticationManager authenticationManager, CustomResponseUtil customResponseUtil, JwtUtil jwtUtil){
        super(authenticationManager);
        this.customResponseUtil = customResponseUtil;
        this.jwtUtil = jwtUtil;
        setFilterProcessesUrl("/login");
        this.authenticationManager=authenticationManager;
    }
```

생성자를 수정해야하고, SecurityConfig에도 가서 등록한뒤 넣어준다

`private final JwtUtil jwtUtil;` 추가

``` java
http.addFilterAt(new LoginFilter(authenticationManager(authenticationConfiguration), customResponseUtil, jwtUtil), UsernamePasswordAuthenticationFilter.class);
```

이후 LoginFilter에서 로그인 성공시 토큰 반환하도록 `successfulAuthentication` 메서드를 수정한다

```java
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain
            , Authentication authentication)throws IOException, ServletException{

        LoginMember loginMember = (LoginMember) authentication.getPrincipal(); // 유저 객체 가져오기
        String username = loginMember.getUsername();

        log.info("successfulAuthentication : username = {}", username); // username을 가져오기

        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        Iterator<? extends GrantedAuthority> iterator = authorities.iterator();
        GrantedAuthority auth = iterator.next();

        String role = auth.getAuthority();

        String accessToken = jwtUtil.createAccessToken(username, role, 60*60*10L);

        response.addHeader("Authorization", "Bearer " + accessToken);

        log.info("successfulAuthentication : login memberId = {}", loginMember.getMember().getId());

//        String accessToken = JwtProcess.createAccessToken(loginUser);
//        String refreshToken = JwtProcess.createRefreshToken(loginUser);
//        response.addHeader(JwtVO.HEADER, accessToken);
//        response.addHeader(JwtVO.REFRESH_HEADER, refreshToken);
//        int memberId = loginUser.getMember().getMemberId();
//        System.out.println("MemberId = "+loginUser.getMember().getMemberId());

        customResponseUtil.success(response, loginMember.getMember().getId());
    }
```

주석 처리는 예전 프로젝트 때 했던 방식인데, 혹시 몰라 남겨둔다

Http 인증 방식은 Bearer 인증토큰String 형식을 반드시 지켜야 한다

실행해보니까 오류가 났다

Component를 달아놓은 JwtUtil에서 오류가 났는데, 기본 생성자가 없다고 판단되어

`NoArgsConstructor`를 달아주었다 맞나 모르겠네 일단 오류는 안난다 빈도 만들어졌다

하지만 다음 Role을 저장해주지 않아서 문제가 생겼다

이 부분도 해결했다

그런데 SecretKey를 불러오지 못한다

JwtUtil 생성자가 작동하지 않는다

해결방법

JwtUtil에 `@NoArgsConstructor` 어노테이션 제거 후 SecretKey를 static final로 선언해줬다

refreshToken도 같은 방법으로 설정해서 이제 헤더에 담기긴한다

그럼 이걸 redis로 보내는 단계가 남았다

## REDIS를 써보자

우선 yml에 spring.data.redis 밑에 host, port, password를 설정해줬다

그리고 RedisConfig 클래스를 생성해 `@Configuration`을 생성

### docker-compose.yml

```yml
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
    environment:
      - REDIS_PASSWORD=thxdragon123!
    container_name: redis-thx-dragon
```

### application.yml
```yml
  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      password: ${REDIS_PASSWORD}
```
### .env
```.env
REDIS_HOST=localhost
REDIS_PORT=6379
```

### RedisConfig

```java
package thx.dragon.thxdragon.global.config.redis;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.repository.configuration.EnableRedisRepositories;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@EnableRedisRepositories
public class RedisConfig {

    @Value("${spring.data.redis.host}")
    private String redisHost;

    @Value("${spring.data.redis.port}")
    private String redisPort;

    @Value("${spring.data.redis.password}")
    private String redisPassword;

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        redisStandaloneConfiguration.setHostName(redisHost);
        redisStandaloneConfiguration.setPort(Integer.parseInt(redisPort));
        redisStandaloneConfiguration.setPassword(redisPassword);
        LettuceConnectionFactory lettuceConnectionFactory = new LettuceConnectionFactory(redisStandaloneConfiguration);
        return lettuceConnectionFactory;
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory());
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());
        return redisTemplate;
    }
}
```

### RedisService
```java
package thx.dragon.thxdragon.global.config.redis;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
@RequiredArgsConstructor
public class RedisService {

    private final RedisTemplate<String, String> redisTemplate;

    public String getValues(String key){
        ValueOperations<String, String> values = redisTemplate.opsForValue();
        return values.get(key);
    }

    public void setValues(String key,String value){
        redisTemplate.opsForValue().set(key,value);
        redisTemplate.expire(key,14, TimeUnit.DAYS);
    }

    public void expireValues(String key){
        redisTemplate.expire(key,0, TimeUnit.SECONDS);
    }
}
```

redis에 저장도 해줬으니 이제 검증 필터를 다시 만들어보자

## JwtFilter 생성

우선 JwtFilter에 JwtUtil을 주입받는다(사용해야 하기 때문에)

그 전에 회원 검증하는 로직을 만들어 주었다(나중에 닉네임 설정 창으로 갈지, 아니면 바로 메인으로 갈지 프론트에 넘겨주려고)

아래 코드 맨 밑에 String code 부분을 추가해 응답을 넘겼다



```java
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain
            , Authentication authentication)throws IOException, ServletException{

        LoginMember loginMember = (LoginMember) authentication.getPrincipal(); // 유저 객체 가져오기
        String username = loginMember.getUsername();

        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        Iterator<? extends GrantedAuthority> iterator = authorities.iterator();
        GrantedAuthority auth = iterator.next();

        String role = auth.getAuthority();

        log.info("successfulAuthentication : username = {} {}", username, role); // username을 가져오기

        String accessToken = jwtUtil.createAccessToken(username, role, 60*60*10L); // 60*60*10L
        String refreshToken = jwtUtil.createRefreshToken(username, role, 60*60*24*14*10L);


        response.addHeader("Authorization", "Bearer " + accessToken);
        response.addHeader("RefreshToken", "Bearer " + refreshToken);

        log.info("successfulAuthentication : login memberId = {}", loginMember.getMember().getId());
        String code = loginMember.getMember().getNickname();

        customResponseUtil.success(response, code, loginMember.getMember().getId());
    }
```

여기서 전체적인 코드 수정을 했다.. username 과 관련된 부분들을 전부 kakaoId를 기준으로 가져오도록 했다

나중에 유저 닉네임이랑 이런거 가져오도록 좀 더 손봐야겠다

# 전체 코드

## SecurityConfig

``` java
package thx.dragon.thxdragon.global.config.security;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import thx.dragon.thxdragon.global.config.jwt.JwtFilter;
import thx.dragon.thxdragon.global.config.jwt.JwtUtil;
import thx.dragon.thxdragon.global.config.jwt.LoginFilter;
import thx.dragon.thxdragon.global.util.CustomResponseUtil;

import java.util.Collections;

@Configuration
@Slf4j
@RequiredArgsConstructor
@EnableWebSecurity
public class SecurityConfig {

    private final AuthenticationConfiguration authenticationConfiguration;

    private final CustomResponseUtil customResponseUtil;

    private final JwtUtil jwtUtil;

    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        log.info("debug : BCryptPasswordEncoder 빈 등록됨");
        return new BCryptPasswordEncoder();
    }

    // 계층 권한 설정
    @Bean
    public RoleHierarchy roleHierarchy() {
        RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();

        // 여기에 계층 구조를 개행으로 입력
        hierarchy.setHierarchy("ADMIN > JOIN\n" +
                "JOIN > LEAVE");

        return hierarchy;
    }

    // AuthenticationManger Bean 등록
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception{
        return configuration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        log.info("debug : FilterChain 등록");

        http.
                cors((cors ) -> cors
                .configurationSource(new CorsConfigurationSource() {
                    @Override
                    public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
                        log.debug("getCorsConfiguration : configurationSource cors 설정이 SecurityFilterChain에 등록됨");
                        CorsConfiguration configuration = new CorsConfiguration();

                        configuration.setAllowedOrigins(Collections.singletonList("http://localhost:3000"));
                        configuration.setAllowedMethods(Collections.singletonList("*"));
                        configuration.setAllowCredentials(true);
                        configuration.setAllowedHeaders(Collections.singletonList("*"));
                        configuration.setMaxAge(3600L);

                        configuration.setExposedHeaders(Collections.singletonList("Authorization"));
                        configuration.setExposedHeaders(Collections.singletonList("Refreshtoken"));

//                        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
//                        source.registerCorsConfiguration("/**",configuration);

                        log.info("getCorsConfiguration : configurationSource 종료");

                        return configuration;
                    }}));

        // csrf disable?: 세션 방식이 항상 고정되기 때문에 막아줘야 하지만, JWT가 STATELESS 방식으로 막아준다
        http
                .csrf((auth) -> auth.disable());
        http
                .formLogin((auth) -> auth.disable());
        http
                .httpBasic((auth) -> auth.disable());

        // 인가 작업
        http
                .authorizeHttpRequests((auth) -> auth
                        .requestMatchers("/login", "/", "*/join", "*/check").permitAll()
                        .anyRequest().authenticated()
                );

        http
                .addFilterBefore(new JwtFilter(jwtUtil), LoginFilter.class);

        http
                .addFilterAt(new LoginFilter(authenticationManager(authenticationConfiguration), customResponseUtil, jwtUtil), UsernamePasswordAuthenticationFilter.class);


        // 세션 설정, 중요하다(JWT 방식에서는)
        http
                .sessionManagement((session) -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        log.info("debug : FilterChain 종료");

        return http.build();
    }

//    public CorsConfigurationSource configurationSource(){
//        log.debug("debug : configurationSource cors 설정이 SecurityFilterChain에 등록됨");
//        CorsConfiguration configuration = new CorsConfiguration();
//        configuration.addAllowedHeader("*");
//        configuration.addAllowedMethod("*"); //
//        configuration.addAllowedOriginPattern("*");
//        configuration.setAllowCredentials(true);
//        configuration.addExposedHeader("Authorization");
//        configuration.addExposedHeader("Refreshtoken");
//        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
//        source.registerCorsConfiguration("/**",configuration);
//        log.info("debug : CorsConfig 종료");
//        return source;
//    }

}
```

## JwtUtil

``` java
package thx.dragon.thxdragon.global.config.jwt;

import io.jsonwebtoken.Jwts;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Component
@Slf4j
public class JwtUtil {

    private final SecretKey secretKey;

    public JwtUtil(@Value("${jwt.secret}") String secret) {
        log.info("JwtUtil : secret = {}", secret);
        secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), Jwts.SIG.HS256.key().build().getAlgorithm());
    }

    public String getKakaoId(String token) {

        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().get("kakaoId", String.class);
    }

    public String getRole(String token) {

        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().get("role", String.class);
    }

    public Boolean isExpired(String token) {

        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().getExpiration().before(new Date());
    }

    public String createAccessToken(String kakaoId, String role, Long expiredMs) {

        log.info("createAccessToken secret key =  {}", secretKey);

        return Jwts.builder()
                .claim("kakaoId", kakaoId) // payload에 kakaoId
                .claim("role", role) // payload에 role
                .issuedAt(new Date(System.currentTimeMillis())) // 토큰 발행일
                .expiration(new Date(System.currentTimeMillis() + expiredMs)) // 토큰 만료일
                .signWith(secretKey) // 암호화
                .compact(); // 토큰 compact 후 발행
    }

    public String createRefreshToken(String kakaoId, String role, Long expiredMs) {

        log.info("createRefreshToken secret key =  {}", secretKey);

        return Jwts.builder()
                .claim("kakaoId", kakaoId) // payload에 kakaoId
                .claim("role", role) // payload에 role
                .issuedAt(new Date(System.currentTimeMillis())) // 토큰 발행일
                .expiration(new Date(System.currentTimeMillis() + expiredMs)) // 토큰 만료일
                .signWith(secretKey) // 암호화
                .compact(); // 토큰 compact 후 발행
    }

}
```

## LoginFilter

``` java
package thx.dragon.thxdragon.global.config.jwt;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import thx.dragon.thxdragon.global.config.auth.LoginMember;
import thx.dragon.thxdragon.global.status.MemberStatus;
import thx.dragon.thxdragon.global.util.CustomResponseUtil;
import thx.dragon.thxdragon.member.dto.request.LoginReqDto;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;

@Slf4j
public class LoginFilter extends UsernamePasswordAuthenticationFilter {

    private final AuthenticationManager authenticationManager;

    private final CustomResponseUtil customResponseUtil;

    private final JwtUtil jwtUtil;

    public LoginFilter(AuthenticationManager authenticationManager, CustomResponseUtil customResponseUtil, JwtUtil jwtUtil){
        super(authenticationManager);
        this.customResponseUtil = customResponseUtil;
        this.jwtUtil = jwtUtil;
        setFilterProcessesUrl("/login");
        this.authenticationManager = authenticationManager;
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        try {
            log.info("LoginFilter attempAuthentication 실행");

            ObjectMapper om = new ObjectMapper();

            LoginReqDto loginReqDto = om.readValue(request.getInputStream(),LoginReqDto.class);
            String username = loginReqDto.getCode();
            String password = "";
            log.info("Jwt Authentication Filter username = {}", username);

            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                    username,password, null
            );

            return authenticationManager.authenticate(authenticationToken);

        } catch(Exception e) {
            log.info("attempAuthentication 오류");
            throw new InternalAuthenticationServiceException(e.getMessage());
        }
    }

    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain
            , Authentication authentication)throws IOException, ServletException{

        LoginMember loginMember = (LoginMember) authentication.getPrincipal(); // 유저 객체 가져오기
        String username = loginMember.getUsername(); // kakao Id가 담겨있어야 한다

        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        Iterator<? extends GrantedAuthority> iterator = authorities.iterator();
        GrantedAuthority auth = iterator.next();

        String role = auth.getAuthority();

        log.info("successfulAuthentication : username = {} {}", username, role); // username을 가져오기

        String accessToken = jwtUtil.createAccessToken(username, role, 60*60*10L); // 60*60*10L
        String refreshToken = jwtUtil.createRefreshToken(username, role, 60*60*24*14*10L);


        response.addHeader("Authorization", "Bearer " + accessToken);
        response.addHeader("RefreshToken", "Bearer " + refreshToken);

        log.info("successfulAuthentication : login memberId = {}", loginMember.getMember().getId());
        String code = loginMember.getMember().getNickname();

        customResponseUtil.success(response, code, Long.parseLong(loginMember.getMember().getKakaoId()));
    }

    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request,HttpServletResponse response
            ,AuthenticationException failed) throws IOException, ServletException{
        customResponseUtil.fail(response,"로그인 실패", HttpStatus.UNAUTHORIZED);
    }
}
```

## JwtFilter

``` java
package thx.dragon.thxdragon.global.config.jwt;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;
import thx.dragon.thxdragon.global.config.auth.LoginMember;
import thx.dragon.thxdragon.member.dto.request.LoginReqDto;
import thx.dragon.thxdragon.member.entity.Member;

import java.io.IOException;

@Slf4j
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String authorization = request.getHeader("Authorization");

        if(authorization == null) {
            log.info("doFilterInternal : authorization == null");
            filterChain.doFilter(request, response);
            return;
        }

        if(!authorization.startsWith("Bearer ")) {
            log.info("doFilterInternal : authorization not start Bearer ");
            filterChain.doFilter(request, response);
            return;
        }

        log.info("doFilterInternal : get authorization token");

        String token = authorization.split(" ")[1]; // Bearer 제거한 나머지 실제 토큰 값

        // 토큰 시간이 만료되었는지 검증
        if(jwtUtil.isExpired(token)) {
            log.info("doFilterInternal : token expired");
            filterChain.doFilter(request, response);
            return;
        }

        String username = jwtUtil.getKakaoId(token);
        String role = jwtUtil.getRole(token);

        Member newMember = new Member();
        newMember.setKakaoId(username);

        log.info("JwtUtil Filter : token = {}, user name = {}, newMember.getKakaoId = {}", token, username, newMember.getKakaoId());

        //UserDetails에 회원 정보 객체 담기
        LoginMember loginMember = new LoginMember(newMember);

        // 스프링 시큐리티 인증 토큰 생성
        Authentication authToken = new UsernamePasswordAuthenticationToken(loginMember, null, loginMember.getAuthorities());

        // 세션에 사용자 등록
        SecurityContextHolder.getContext().setAuthentication(authToken);

        filterChain.doFilter(request, response);

    }
}
```

## LoginMember

``` java
package thx.dragon.thxdragon.global.config.auth;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import thx.dragon.thxdragon.member.entity.Member;

import java.util.ArrayList;
import java.util.Collection;

@Getter
@RequiredArgsConstructor
public class LoginMember implements UserDetails {

    private static final long serialVersionUID = 1L;

    private final Member member;

    // 해당 유저의 권한을 return
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        Collection<GrantedAuthority> collection= new ArrayList<>();
        collection.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                return member.getMemberStatus().name();
            }
        });

        return collection;
    }

    @Override
    public String getPassword() {
        return member.getPassword();
    }

    @Override
    public String getUsername() {
        return member.getKakaoId();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    // 휴면 계정 설정 같은거 할 수 있음
    @Override
    public boolean isEnabled() {
        return true;
    }
}
```

## LoginMemberService

``` java
package thx.dragon.thxdragon.global.config.auth;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import thx.dragon.thxdragon.global.error.ErrorCode;
import thx.dragon.thxdragon.global.error.exception.TokenException;
import thx.dragon.thxdragon.global.status.MemberStatus;
import thx.dragon.thxdragon.member.entity.Member;
import thx.dragon.thxdragon.member.exception.MemberException;
import thx.dragon.thxdragon.member.repository.MemberRepository;
import thx.dragon.thxdragon.member.service.KakaoLoginService;
import thx.dragon.thxdragon.member.service.MemberService;

import java.util.Optional;
import java.util.StringTokenizer;

@Service
@Slf4j
@RequiredArgsConstructor
public class LoginMemberService implements UserDetailsService {

    private final MemberRepository memberRepository;

    private final KakaoLoginService kakaoLoginService;

    private final MemberService memberService;

    @Override
    public UserDetails loadUserByUsername(String code) throws UsernameNotFoundException {

        log.info("loadUserByUsername 실행 : code = {}", code);

        String accessToken = kakaoLoginService.getKakaoAccessToken(code);
        log.info("LoginMemberService : accessToken = {}", accessToken);

        String kakaoInfo = kakaoLoginService.createKakaoUser(accessToken); // 카카오 아이디 값
        StringTokenizer st = new StringTokenizer(kakaoInfo);//카카오 아이디 분리
        String kakaoId = st.nextToken();//카카오 아이디만 가지고 있는 변수
        String email = st.nextToken();

        log.info("LoginMemberService : kakaoId = {} email = {}", kakaoId, email);

        // 혹시나 kakaoId를 못가져왔으면, 로그인 실패
        if(kakaoId.isEmpty() || kakaoId.equals(null)){
            log.info("Login Service kakaoId null");
            throw new InternalAuthenticationServiceException("로그인 실패");
        }
        // 카카오 아이디로 멤버 가져오기
        Optional<Member> userPS = memberRepository.findByKakaoId(kakaoId);
        log.info("LoginMemberService : userPS 설정");
        
        // 멤버가 없으면 가입해야 한다
        if(userPS.isEmpty()){
            log.info("Login Service 가져온 member가 없다");

            Member newMember = memberService.join(kakaoId, email);
            log.info("Login Service 등록이 완료되었다");

            if(newMember == null){
                log.info("Login Service newMember 부재");
                throw new InternalAuthenticationServiceException("인증 및 가입 실패");
            }

            return new LoginMember(newMember);
        }

        if(userPS.get().getMemberStatus() == MemberStatus.LEAVE) {
            log.info("userPS는 탈퇴된 회원입니다.");
            Member comebackMember = memberService.rejoin(userPS.get());

            return new LoginMember(comebackMember);
        }
        
        // 있을 때, LEAVE 상태가 아니면 해당 멤버를 가져온다
        log.info("Login Service userPS 존재");
        return new LoginMember(userPS.get());

    }
}
```

## RedisConfig

``` java
package thx.dragon.thxdragon.global.config.redis;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.repository.configuration.EnableRedisRepositories;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@EnableRedisRepositories
public class RedisConfig {

    @Value("${spring.data.redis.host}")
    private String redisHost;

    @Value("${spring.data.redis.port}")
    private String redisPort;

    @Value("${spring.data.redis.password}")
    private String redisPassword;

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        redisStandaloneConfiguration.setHostName(redisHost);
        redisStandaloneConfiguration.setPort(Integer.parseInt(redisPort));
        redisStandaloneConfiguration.setPassword(redisPassword);
        LettuceConnectionFactory lettuceConnectionFactory = new LettuceConnectionFactory(redisStandaloneConfiguration);
        return lettuceConnectionFactory;
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory());
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());
        return redisTemplate;
    }
}
```

## RedisService

``` java
package thx.dragon.thxdragon.global.config.redis;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
@RequiredArgsConstructor
public class RedisService {

    private final RedisTemplate<String, String> redisTemplate;

    public String getValues(String key){
        ValueOperations<String, String> values = redisTemplate.opsForValue();
        return values.get(key);
    }

    public void setValues(String key,String value){
        redisTemplate.opsForValue().set(key,value);
        redisTemplate.expire(key,14, TimeUnit.DAYS);
    }

    public void expireValues(String key){
        redisTemplate.expire(key,0, TimeUnit.SECONDS);
    }
}
```

## CorsMvcConfig

``` java
package thx.dragon.thxdragon.global.config;

import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

public class CorsMvcConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {

        registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000");
    }
}
```

## CustomResponseUtil
``` java
package thx.dragon.thxdragon.global.util;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletResponse;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import thx.dragon.thxdragon.global.config.redis.RedisService;

@Component
@Slf4j
@RequiredArgsConstructor
public class CustomResponseUtil {

    private final RedisService redisService;

//    @Autowired
//    public CustomResponseUtil(RedisService redisService){
//        this.redisService = redisService;
//    }
    @Getter
    @Setter
    public class CodeResDto {
        private String code;
        private String msg;
}

    public void success(HttpServletResponse response, String code, Long memberId){
        try{
            response.setContentType("application/json; charset=utf-8");
            response.setStatus(200);
            CodeResDto codeResDto = new CodeResDto();
            if(code == null) {
                codeResDto.setCode("001");
                codeResDto.setMsg("로그인 성공 / 닉네임 설정 필요");
            }
            else {
                codeResDto.setCode("002");
                codeResDto.setMsg("로그인 성공 / 바로 메인으로");
            }

            ObjectMapper objectMapper = new ObjectMapper();
            String resJson = objectMapper.writeValueAsString(codeResDto);

            response.getWriter().println(resJson);

            String refreshToken = response.getHeader("RefreshToken");
            redisService.setValues(String.valueOf(memberId), refreshToken);

        } catch(Exception e) {
            e.printStackTrace();
            log.error("서버 파싱 에러");
        }
    }
    public static void fail(HttpServletResponse response, String msg, HttpStatus httpStatus){
        try{
            response.setContentType("application/json; charset=utf-8");
            response.setStatus(httpStatus.value());
            response.getWriter().println(msg);

        }catch (Exception e){
            e.printStackTrace();
            log.error("서버 파싱 에러");
        }
    }
}
```

# JWT의 궁극적인 목표?
