# 섹션 2 - 예제 도메인 모델

## 예제 도메인 모델과 동작 확인

`NoArgsConstructor(access = AccessLevel.PROTECTED)`

`ManyToOne(fetch = FetchType.LAZY)`

연관관계 편의 메서드

정도만 전에 했던거로 기억해두자

# 섹션 3 - 공통 인터페이스 기능

## 순수 JPA 기반 리포지토리 만들기

`em.persist(member)`, `em.remove(member)`,</br>
`em.createQuery(select m from Member m", Member.class).getResultList()`

등을 통해 기본 리포지토리 기능 생성

# 섹션 4 - 쿼리 메소드 기능

이름만으로 해결되지 않는 경우 또는 너무 길어지는 경우(단순한 경우만 이름으로 사용) NamedQuery 방법과 @Query 방법이 있는데,

보통의 경우 `@Query`를 사용해서 JPQL을 사용한다

## 반환 타입

Optional, Collection, 객체 등 다양한 반환 타입 설정 가능

## 페이징과 정렬

```java
// Repository
Page<Member> findByAge(int age, Pageable pagealbe);

```

```java
// 페이지, size, sorting
PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, "username"));

Page<Member> page = memberRepository.findByAge(age, pageRequest);

List<Member> content = page.getContent(); // 데이터 꺼내오기

long totalElement = page.getTotalElements(); // 페이지 카운팅도 알아서 날린다

```

Slice?

3개 가져오라 보내면 한 개 더 가져온다

페이징 활용

```java

Page<MeberDto> toMap = page.map(member -> new MemberDto(member.getId(), member.getUsername()));

```

위와 같이 다른 형태로 변경하기 쉽다

## 벌크성 수정쿼리

한 번에 값을 바꾸는 것

executeUpdate와 같은 역할을 하도록 만들기 위해 @Modifying 어노테이션을 붙인다

```java
@Modifying
@Query("update Member m set m.age = m.age + 1 where m.age >= :age")
int bulkAgePlus(@Param("age") int age);

// 이것과 동일하다

public int bulkAgePlus(int age) {
    return em.createQuery(
        "update m set m.age = m.age + 1" +
        " where m.age >= :age")
        .setParameter("age", age)
        .executeUpdate();
}


```

벌크성 업데이트는 조심해야 한다. 영속성 컨텍스트와 관련된 문제

영속성 컨텍스트와 DB 사이에 차이가 생길 수 있다(벌크 연산은 DB에 바로 입력해버린다)

벌크연산 이후에는 영속성 컨텍스트를 날려줘야 한다

```java
@PersistenceContext
EntityManager em;

// ... 기타 코드

em.flush(); // 남아있는 변경 안된 부분 적용
em.clear(); // 날리기

```

SpringDataJPA에서 지원하는걸 쓰자

`@Modifying(clearAutomatically = true)`

## EntityGraph

### Fetch Join

N+1 문제를 해결하기 위해 사용

Fetch Join을 할 수 있는 방법

```java
@Override
@EntityGraph(attributePaths = {"team"})
List<Member> findAll();
```

EntityGraph가 FetchJoin 역할을 해준다

JPQL에도 사용 가능

```java
@EntityGraph(attributePaths = {"team"})
@Query("select m from Member m")
List<Member> findAll();
```

단순한 경우에는 EntityGraph를 사용하고, 웬만한 경우에는 Fetch Join을 사용한다

```java
@Query("select m from Member m left join fetch m.team")
List<Member> findAll();
```

## JPA Hint와 Lock

### Hint

```java
@QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))
Member findReadOnlyByUsername(String username);

```

과 같은 형식으로 사용

변경이 안된다(ReadOnly)

성능테스트 해보고 사용 - 그냥 막 사용할 필요 없음(보통 성능 문제로 Redis를 사용한다 그런데 이 부분만 해결하면 될 때 ReadOnly 처리)

### Lock

```java

@Lock(LockModeType.PESSIMISTIC_WRITE) // javax.persistence 내에 있음
List<Member> findLockByUsername(String username);

```

Lock은 책을 참고해서 이해해보자

select 맨 뒤에 for update라는 쿼리가 날아간다
